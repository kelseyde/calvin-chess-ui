import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-MYQCFY5U.js";

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React = require_react();
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x2) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var assign = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x2) {
                var match = x2.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x2) {
                  control = x2;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x2) {
                  control = x2;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x2) {
                control = x2;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                c2--;
              }
              for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                if (sampleLines[s2] !== controlLines[c2]) {
                  if (s2 !== 1 || c2 !== 1) {
                    do {
                      s2--;
                      c2--;
                      if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component) {
          var prototype = Component.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x2) {
                }
              }
            }
          }
          return "";
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray(a2) {
          return isArrayImpl(a2);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e3) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config, self2) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type, config, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              {
                checkKeyStringCoercion(maybeKey);
              }
              key = "" + maybeKey;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            if (hasValidRef(config)) {
              ref = config.ref;
              warnIfStringRefCannotBeAutoConverted(config, self2);
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i2 = 0; i2 < node.length; i2++) {
                var child = node[i2];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i2 = 0; i2 < keys.length; i2++) {
              var key = keys[i2];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (isArray(children)) {
                    for (var i2 = 0; i2 < children.length; i2++) {
                      validateChildKeys(children[i2], type);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type);
                }
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type, props, key) {
          {
            return jsxWithValidation(type, props, key, false);
          }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = jsx;
        exports.jsxs = jsxs;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/react-chessboard/dist/index.esm.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var m = (0, import_react.createContext)({ dragDropManager: void 0 });
var b = "function" == typeof Symbol && Symbol.observable || "@@observable";
var O = function() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var w = { INIT: "@@redux/INIT" + O(), REPLACE: "@@redux/REPLACE" + O(), PROBE_UNKNOWN_ACTION: function() {
  return "@@redux/PROBE_UNKNOWN_ACTION" + O();
} };
function S(e3) {
  if (void 0 === e3)
    return "undefined";
  if (null === e3)
    return "null";
  var t2 = typeof e3;
  switch (t2) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return t2;
  }
  if (Array.isArray(e3))
    return "array";
  if (function(e4) {
    return e4 instanceof Date || "function" == typeof e4.toDateString && "function" == typeof e4.getDate && "function" == typeof e4.setDate;
  }(e3))
    return "date";
  if (function(e4) {
    return e4 instanceof Error || "string" == typeof e4.message && e4.constructor && "number" == typeof e4.constructor.stackTraceLimit;
  }(e3))
    return "error";
  var r2 = function(e4) {
    return "function" == typeof e4.constructor ? e4.constructor.name : null;
  }(e3);
  switch (r2) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return r2;
  }
  return t2.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function D(e3) {
  var t2 = typeof e3;
  return t2 = S(e3), t2;
}
function C(e3, t2, r2) {
  var n2;
  if ("function" == typeof t2 && "function" == typeof r2 || "function" == typeof r2 && "function" == typeof arguments[3])
    throw new Error(false ? y(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if ("function" == typeof t2 && void 0 === r2 && (r2 = t2, t2 = void 0), void 0 !== r2) {
    if ("function" != typeof r2)
      throw new Error(false ? y(1) : "Expected the enhancer to be a function. Instead, received: '" + D(r2) + "'");
    return r2(C)(e3, t2);
  }
  if ("function" != typeof e3)
    throw new Error(false ? y(2) : "Expected the root reducer to be a function. Instead, received: '" + D(e3) + "'");
  var o2 = e3, i2 = t2, s2 = [], a2 = s2, c2 = false;
  function u2() {
    a2 === s2 && (a2 = s2.slice());
  }
  function l2() {
    if (c2)
      throw new Error(false ? y(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return i2;
  }
  function d2(e4) {
    if ("function" != typeof e4)
      throw new Error(false ? y(4) : "Expected the listener to be a function. Instead, received: '" + D(e4) + "'");
    if (c2)
      throw new Error(false ? y(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    var t3 = true;
    return u2(), a2.push(e4), function() {
      if (t3) {
        if (c2)
          throw new Error(false ? y(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        t3 = false, u2();
        var r3 = a2.indexOf(e4);
        a2.splice(r3, 1), s2 = null;
      }
    };
  }
  function h2(e4) {
    if (!function(e5) {
      if ("object" != typeof e5 || null === e5)
        return false;
      for (var t4 = e5; null !== Object.getPrototypeOf(t4); )
        t4 = Object.getPrototypeOf(t4);
      return Object.getPrototypeOf(e5) === t4;
    }(e4))
      throw new Error(false ? y(7) : "Actions must be plain objects. Instead, the actual type was: '" + D(e4) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    if (void 0 === e4.type)
      throw new Error(false ? y(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (c2)
      throw new Error(false ? y(9) : "Reducers may not dispatch actions.");
    try {
      c2 = true, i2 = o2(i2, e4);
    } finally {
      c2 = false;
    }
    for (var t3 = s2 = a2, r3 = 0; r3 < t3.length; r3++) {
      (0, t3[r3])();
    }
    return e4;
  }
  return h2({ type: w.INIT }), (n2 = { dispatch: h2, subscribe: d2, getState: l2, replaceReducer: function(e4) {
    if ("function" != typeof e4)
      throw new Error(false ? y(10) : "Expected the nextReducer to be a function. Instead, received: '" + D(e4));
    o2 = e4, h2({ type: w.REPLACE });
  } })[b] = function() {
    var e4, t3 = d2;
    return (e4 = { subscribe: function(e5) {
      if ("object" != typeof e5 || null === e5)
        throw new Error(false ? y(11) : "Expected the observer to be an object. Instead, received: '" + D(e5) + "'");
      function r3() {
        e5.next && e5.next(l2());
      }
      return r3(), { unsubscribe: t3(r3) };
    } })[b] = function() {
      return this;
    }, e4;
  }, n2;
}
function T() {
}
function E(e3, t2, ...r2) {
  if ("undefined" != typeof process && false)
    throw new Error("invariant requires an error message argument");
  if (!e3) {
    let e4;
    if (void 0 === t2)
      e4 = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      let n2 = 0;
      e4 = new Error(t2.replace(/%s/g, function() {
        return r2[n2++];
      })), e4.name = "Invariant Violation";
    }
    throw e4.framesToPop = 1, e4;
  }
}
function I(e3) {
  return "object" == typeof e3;
}
"string" == typeof T.name && "isCrushed" !== T.name && function(e3) {
  "undefined" != typeof console && "function" == typeof console.error && console.error(e3);
  try {
    throw new Error(e3);
  } catch (e4) {
  }
}('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
var k = "dnd-core/INIT_COORDS";
var L = "dnd-core/BEGIN_DRAG";
var P = "dnd-core/PUBLISH_DRAG_SOURCE";
var x = "dnd-core/HOVER";
var M = "dnd-core/DROP";
var N = "dnd-core/END_DRAG";
function j(e3, t2) {
  return { type: k, payload: { sourceClientOffset: t2 || null, clientOffset: e3 || null } };
}
var R = { type: k, payload: { clientOffset: null, sourceClientOffset: null } };
function A(e3) {
  return function(t2 = [], r2 = { publishSource: true }) {
    const { publishSource: n2 = true, clientOffset: o2, getSourceClientOffset: i2 } = r2, s2 = e3.getMonitor(), a2 = e3.getRegistry();
    e3.dispatch(j(o2)), function(e4, t3, r3) {
      E(!t3.isDragging(), "Cannot call beginDrag while dragging."), e4.forEach(function(e5) {
        E(r3.getSource(e5), "Expected sourceIds to be registered.");
      });
    }(t2, s2, a2);
    const c2 = function(e4, t3) {
      let r3 = null;
      for (let n3 = e4.length - 1; n3 >= 0; n3--)
        if (t3.canDragSource(e4[n3])) {
          r3 = e4[n3];
          break;
        }
      return r3;
    }(t2, s2);
    if (null == c2)
      return void e3.dispatch(R);
    let u2 = null;
    if (o2) {
      if (!i2)
        throw new Error("getSourceClientOffset must be defined");
      !function(e4) {
        E("function" == typeof e4, "When clientOffset is provided, getSourceClientOffset must be a function.");
      }(i2), u2 = i2(c2);
    }
    e3.dispatch(j(o2, u2));
    const l2 = a2.getSource(c2).beginDrag(s2, c2);
    if (null == l2)
      return;
    !function(e4) {
      E(I(e4), "Item must be an object.");
    }(l2), a2.pinSource(c2);
    const d2 = a2.getSourceType(c2);
    return { type: L, payload: { itemType: d2, item: l2, sourceId: c2, clientOffset: o2 || null, sourceClientOffset: u2 || null, isSourcePublic: !!n2 } };
  };
}
function q(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
function _(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {}, n2 = Object.keys(r2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(r2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(r2, e4).enumerable;
    }))), n2.forEach(function(t3) {
      q(e3, t3, r2[t3]);
    });
  }
  return e3;
}
function z(e3) {
  return function(t2 = {}) {
    const r2 = e3.getMonitor(), n2 = e3.getRegistry();
    !function(e4) {
      E(e4.isDragging(), "Cannot call drop while not dragging."), E(!e4.didDrop(), "Cannot call drop twice during one drag operation.");
    }(r2);
    const o2 = function(e4) {
      const t3 = e4.getTargetIds().filter(e4.canDropOnTarget, e4);
      return t3.reverse(), t3;
    }(r2);
    o2.forEach((o3, i2) => {
      const s2 = function(e4, t3, r3, n3) {
        const o4 = r3.getTarget(e4);
        let i3 = o4 ? o4.drop(n3, e4) : void 0;
        (function(e5) {
          E(void 0 === e5 || I(e5), "Drop result must either be an object or undefined.");
        })(i3), void 0 === i3 && (i3 = 0 === t3 ? {} : n3.getDropResult());
        return i3;
      }(o3, i2, n2, r2), a2 = { type: M, payload: { dropResult: _({}, t2, s2) } };
      e3.dispatch(a2);
    });
  };
}
function H(e3) {
  return function() {
    const t2 = e3.getMonitor(), r2 = e3.getRegistry();
    !function(e4) {
      E(e4.isDragging(), "Cannot call endDrag while not dragging.");
    }(t2);
    const n2 = t2.getSourceId();
    if (null != n2) {
      r2.getSource(n2, true).endDrag(t2, n2), r2.unpinSource();
    }
    return { type: N };
  };
}
function B(e3, t2) {
  return null === t2 ? null === e3 : Array.isArray(e3) ? e3.some((e4) => e4 === t2) : e3 === t2;
}
function W(e3) {
  return function(t2, { clientOffset: r2 } = {}) {
    !function(e4) {
      E(Array.isArray(e4), "Expected targetIds to be an array.");
    }(t2);
    const n2 = t2.slice(0), o2 = e3.getMonitor(), i2 = e3.getRegistry();
    return function(e4, t3, r3) {
      for (let n3 = e4.length - 1; n3 >= 0; n3--) {
        const o3 = e4[n3];
        B(t3.getTargetType(o3), r3) || e4.splice(n3, 1);
      }
    }(n2, i2, o2.getItemType()), function(e4, t3, r3) {
      E(t3.isDragging(), "Cannot call hover while not dragging."), E(!t3.didDrop(), "Cannot call hover after drop.");
      for (let t4 = 0; t4 < e4.length; t4++) {
        const n3 = e4[t4];
        E(e4.lastIndexOf(n3) === t4, "Expected targetIds to be unique in the passed array.");
        E(r3.getTarget(n3), "Expected targetIds to be registered.");
      }
    }(n2, o2, i2), function(e4, t3, r3) {
      e4.forEach(function(e5) {
        r3.getTarget(e5).hover(t3, e5);
      });
    }(n2, o2, i2), { type: x, payload: { targetIds: n2, clientOffset: r2 || null } };
  };
}
function U(e3) {
  return function() {
    if (e3.getMonitor().isDragging())
      return { type: P };
  };
}
var F = class {
  receiveBackend(e3) {
    this.backend = e3;
  }
  getMonitor() {
    return this.monitor;
  }
  getBackend() {
    return this.backend;
  }
  getRegistry() {
    return this.monitor.registry;
  }
  getActions() {
    const e3 = this, { dispatch: t2 } = this.store;
    const r2 = function(e4) {
      return { beginDrag: A(e4), publishDragSource: U(e4), hover: W(e4), drop: z(e4), endDrag: H(e4) };
    }(this);
    return Object.keys(r2).reduce((n2, o2) => {
      const i2 = r2[o2];
      var s2;
      return n2[o2] = (s2 = i2, (...r3) => {
        const n3 = s2.apply(e3, r3);
        void 0 !== n3 && t2(n3);
      }), n2;
    }, {});
  }
  dispatch(e3) {
    this.store.dispatch(e3);
  }
  constructor(e3, t2) {
    this.isSetUp = false, this.handleRefCountChange = () => {
      const e4 = this.store.getState().refCount > 0;
      this.backend && (e4 && !this.isSetUp ? (this.backend.setup(), this.isSetUp = true) : !e4 && this.isSetUp && (this.backend.teardown(), this.isSetUp = false));
    }, this.store = e3, this.monitor = t2, e3.subscribe(this.handleRefCountChange);
  }
};
function $(e3, t2) {
  return { x: e3.x - t2.x, y: e3.y - t2.y };
}
var V = [];
var Y = [];
V.__IS_NONE__ = true, Y.__IS_ALL__ = true;
var K = class {
  subscribeToStateChange(e3, t2 = {}) {
    const { handlerIds: r2 } = t2;
    E("function" == typeof e3, "listener must be a function."), E(void 0 === r2 || Array.isArray(r2), "handlerIds, when specified, must be an array of strings.");
    let n2 = this.store.getState().stateId;
    return this.store.subscribe(() => {
      const t3 = this.store.getState(), o2 = t3.stateId;
      try {
        const i2 = o2 === n2 || o2 === n2 + 1 && !function(e4, t4) {
          return e4 !== V && (e4 === Y || void 0 === t4 || (r3 = e4, t4.filter((e5) => r3.indexOf(e5) > -1)).length > 0);
          var r3;
        }(t3.dirtyHandlerIds, r2);
        i2 || e3();
      } finally {
        n2 = o2;
      }
    });
  }
  subscribeToOffsetChange(e3) {
    E("function" == typeof e3, "listener must be a function.");
    let t2 = this.store.getState().dragOffset;
    return this.store.subscribe(() => {
      const r2 = this.store.getState().dragOffset;
      r2 !== t2 && (t2 = r2, e3());
    });
  }
  canDragSource(e3) {
    if (!e3)
      return false;
    const t2 = this.registry.getSource(e3);
    return E(t2, `Expected to find a valid source. sourceId=${e3}`), !this.isDragging() && t2.canDrag(this, e3);
  }
  canDropOnTarget(e3) {
    if (!e3)
      return false;
    const t2 = this.registry.getTarget(e3);
    if (E(t2, `Expected to find a valid target. targetId=${e3}`), !this.isDragging() || this.didDrop())
      return false;
    return B(this.registry.getTargetType(e3), this.getItemType()) && t2.canDrop(this, e3);
  }
  isDragging() {
    return Boolean(this.getItemType());
  }
  isDraggingSource(e3) {
    if (!e3)
      return false;
    const t2 = this.registry.getSource(e3, true);
    if (E(t2, `Expected to find a valid source. sourceId=${e3}`), !this.isDragging() || !this.isSourcePublic())
      return false;
    return this.registry.getSourceType(e3) === this.getItemType() && t2.isDragging(this, e3);
  }
  isOverTarget(e3, t2 = { shallow: false }) {
    if (!e3)
      return false;
    const { shallow: r2 } = t2;
    if (!this.isDragging())
      return false;
    const n2 = this.registry.getTargetType(e3), o2 = this.getItemType();
    if (o2 && !B(n2, o2))
      return false;
    const i2 = this.getTargetIds();
    if (!i2.length)
      return false;
    const s2 = i2.indexOf(e3);
    return r2 ? s2 === i2.length - 1 : s2 > -1;
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType;
  }
  getItem() {
    return this.store.getState().dragOperation.item;
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId;
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds;
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult;
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop;
  }
  isSourcePublic() {
    return Boolean(this.store.getState().dragOperation.isSourcePublic);
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset;
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset;
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset;
  }
  getSourceClientOffset() {
    return function(e3) {
      const { clientOffset: t2, initialClientOffset: r2, initialSourceClientOffset: n2 } = e3;
      return t2 && r2 && n2 ? $((i2 = n2, { x: (o2 = t2).x + i2.x, y: o2.y + i2.y }), r2) : null;
      var o2, i2;
    }(this.store.getState().dragOffset);
  }
  getDifferenceFromInitialOffset() {
    return function(e3) {
      const { clientOffset: t2, initialClientOffset: r2 } = e3;
      return t2 && r2 ? $(t2, r2) : null;
    }(this.store.getState().dragOffset);
  }
  constructor(e3, t2) {
    this.store = e3, this.registry = t2;
  }
};
var X = "undefined" != typeof global ? global : self;
var G = X.MutationObserver || X.WebKitMutationObserver;
function Q(e3) {
  return function() {
    const t2 = setTimeout(n2, 0), r2 = setInterval(n2, 50);
    function n2() {
      clearTimeout(t2), clearInterval(r2), e3();
    }
  };
}
var J = "function" == typeof G ? function(e3) {
  let t2 = 1;
  const r2 = new G(e3), n2 = document.createTextNode("");
  return r2.observe(n2, { characterData: true }), function() {
    t2 = -t2, n2.data = t2;
  };
} : Q;
var Z = class {
  call() {
    try {
      this.task && this.task();
    } catch (e3) {
      this.onError(e3);
    } finally {
      this.task = null, this.release(this);
    }
  }
  constructor(e3, t2) {
    this.onError = e3, this.release = t2, this.task = null;
  }
};
var ee = new class {
  enqueueTask(e3) {
    const { queue: t2, requestFlush: r2 } = this;
    t2.length || (r2(), this.flushing = true), t2[t2.length] = e3;
  }
  constructor() {
    this.queue = [], this.pendingErrors = [], this.flushing = false, this.index = 0, this.capacity = 1024, this.flush = () => {
      const { queue: e3 } = this;
      for (; this.index < e3.length; ) {
        const t2 = this.index;
        if (this.index++, e3[t2].call(), this.index > this.capacity) {
          for (let t3 = 0, r2 = e3.length - this.index; t3 < r2; t3++)
            e3[t3] = e3[t3 + this.index];
          e3.length -= this.index, this.index = 0;
        }
      }
      e3.length = 0, this.index = 0, this.flushing = false;
    }, this.registerPendingError = (e3) => {
      this.pendingErrors.push(e3), this.requestErrorThrow();
    }, this.requestFlush = J(this.flush), this.requestErrorThrow = Q(() => {
      if (this.pendingErrors.length)
        throw this.pendingErrors.shift();
    });
  }
}();
var te = new class {
  create(e3) {
    const t2 = this.freeTasks, r2 = t2.length ? t2.pop() : new Z(this.onError, (e4) => t2[t2.length] = e4);
    return r2.task = e3, r2;
  }
  constructor(e3) {
    this.onError = e3, this.freeTasks = [];
  }
}(ee.registerPendingError);
var re = "dnd-core/ADD_SOURCE";
var ne = "dnd-core/ADD_TARGET";
var oe = "dnd-core/REMOVE_SOURCE";
var ie = "dnd-core/REMOVE_TARGET";
function se(e3, t2) {
  t2 && Array.isArray(e3) ? e3.forEach((e4) => se(e4, false)) : E("string" == typeof e3 || "symbol" == typeof e3, t2 ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var ae;
!function(e3) {
  e3.SOURCE = "SOURCE", e3.TARGET = "TARGET";
}(ae || (ae = {}));
var ce = 0;
function ue(e3) {
  const t2 = (ce++).toString();
  switch (e3) {
    case ae.SOURCE:
      return `S${t2}`;
    case ae.TARGET:
      return `T${t2}`;
    default:
      throw new Error(`Unknown Handler Role: ${e3}`);
  }
}
function le(e3) {
  switch (e3[0]) {
    case "S":
      return ae.SOURCE;
    case "T":
      return ae.TARGET;
    default:
      throw new Error(`Cannot parse handler ID: ${e3}`);
  }
}
function de(e3, t2) {
  const r2 = e3.entries();
  let n2 = false;
  do {
    const { done: e4, value: [, o2] } = r2.next();
    if (o2 === t2)
      return true;
    n2 = !!e4;
  } while (!n2);
  return false;
}
var he = class {
  addSource(e3, t2) {
    se(e3), function(e4) {
      E("function" == typeof e4.canDrag, "Expected canDrag to be a function."), E("function" == typeof e4.beginDrag, "Expected beginDrag to be a function."), E("function" == typeof e4.endDrag, "Expected endDrag to be a function.");
    }(t2);
    const r2 = this.addHandler(ae.SOURCE, e3, t2);
    return this.store.dispatch(function(e4) {
      return { type: re, payload: { sourceId: e4 } };
    }(r2)), r2;
  }
  addTarget(e3, t2) {
    se(e3, true), function(e4) {
      E("function" == typeof e4.canDrop, "Expected canDrop to be a function."), E("function" == typeof e4.hover, "Expected hover to be a function."), E("function" == typeof e4.drop, "Expected beginDrag to be a function.");
    }(t2);
    const r2 = this.addHandler(ae.TARGET, e3, t2);
    return this.store.dispatch(function(e4) {
      return { type: ne, payload: { targetId: e4 } };
    }(r2)), r2;
  }
  containsHandler(e3) {
    return de(this.dragSources, e3) || de(this.dropTargets, e3);
  }
  getSource(e3, t2 = false) {
    E(this.isSourceId(e3), "Expected a valid source ID.");
    return t2 && e3 === this.pinnedSourceId ? this.pinnedSource : this.dragSources.get(e3);
  }
  getTarget(e3) {
    return E(this.isTargetId(e3), "Expected a valid target ID."), this.dropTargets.get(e3);
  }
  getSourceType(e3) {
    return E(this.isSourceId(e3), "Expected a valid source ID."), this.types.get(e3);
  }
  getTargetType(e3) {
    return E(this.isTargetId(e3), "Expected a valid target ID."), this.types.get(e3);
  }
  isSourceId(e3) {
    return le(e3) === ae.SOURCE;
  }
  isTargetId(e3) {
    return le(e3) === ae.TARGET;
  }
  removeSource(e3) {
    var t2;
    E(this.getSource(e3), "Expected an existing source."), this.store.dispatch(function(e4) {
      return { type: oe, payload: { sourceId: e4 } };
    }(e3)), t2 = () => {
      this.dragSources.delete(e3), this.types.delete(e3);
    }, ee.enqueueTask(te.create(t2));
  }
  removeTarget(e3) {
    E(this.getTarget(e3), "Expected an existing target."), this.store.dispatch(function(e4) {
      return { type: ie, payload: { targetId: e4 } };
    }(e3)), this.dropTargets.delete(e3), this.types.delete(e3);
  }
  pinSource(e3) {
    const t2 = this.getSource(e3);
    E(t2, "Expected an existing source."), this.pinnedSourceId = e3, this.pinnedSource = t2;
  }
  unpinSource() {
    E(this.pinnedSource, "No source is pinned at the time."), this.pinnedSourceId = null, this.pinnedSource = null;
  }
  addHandler(e3, t2, r2) {
    const n2 = ue(e3);
    return this.types.set(n2, t2), e3 === ae.SOURCE ? this.dragSources.set(n2, r2) : e3 === ae.TARGET && this.dropTargets.set(n2, r2), n2;
  }
  constructor(e3) {
    this.types = /* @__PURE__ */ new Map(), this.dragSources = /* @__PURE__ */ new Map(), this.dropTargets = /* @__PURE__ */ new Map(), this.pinnedSourceId = null, this.pinnedSource = null, this.store = e3;
  }
};
var ge = (e3, t2) => e3 === t2;
function fe(e3 = V, t2) {
  switch (t2.type) {
    case x:
      break;
    case re:
    case ne:
    case ie:
    case oe:
      return V;
    default:
      return Y;
  }
  const { targetIds: r2 = [], prevTargetIds: n2 = [] } = t2.payload, o2 = function(e4, t3) {
    const r3 = /* @__PURE__ */ new Map(), n3 = (e5) => {
      r3.set(e5, r3.has(e5) ? r3.get(e5) + 1 : 1);
    };
    e4.forEach(n3), t3.forEach(n3);
    const o3 = [];
    return r3.forEach((e5, t4) => {
      1 === e5 && o3.push(t4);
    }), o3;
  }(r2, n2);
  if (!(o2.length > 0 || !function(e4, t3, r3 = ge) {
    if (e4.length !== t3.length)
      return false;
    for (let n3 = 0; n3 < e4.length; ++n3)
      if (!r3(e4[n3], t3[n3]))
        return false;
    return true;
  }(r2, n2)))
    return V;
  const i2 = n2[n2.length - 1], s2 = r2[r2.length - 1];
  return i2 !== s2 && (i2 && o2.push(i2), s2 && o2.push(s2)), o2;
}
function pe(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
var ve = { initialSourceClientOffset: null, initialClientOffset: null, clientOffset: null };
function me(e3 = ve, t2) {
  const { payload: r2 } = t2;
  switch (t2.type) {
    case k:
    case L:
      return { initialSourceClientOffset: r2.sourceClientOffset, initialClientOffset: r2.clientOffset, clientOffset: r2.clientOffset };
    case x:
      return n2 = e3.clientOffset, o2 = r2.clientOffset, !n2 && !o2 || n2 && o2 && n2.x === o2.x && n2.y === o2.y ? e3 : function(e4) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var r3 = null != arguments[t3] ? arguments[t3] : {}, n3 = Object.keys(r3);
          "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(r3).filter(function(e5) {
            return Object.getOwnPropertyDescriptor(r3, e5).enumerable;
          }))), n3.forEach(function(t4) {
            pe(e4, t4, r3[t4]);
          });
        }
        return e4;
      }({}, e3, { clientOffset: r2.clientOffset });
    case N:
    case M:
      return ve;
    default:
      return e3;
  }
  var n2, o2;
}
function ye(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
function be(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {}, n2 = Object.keys(r2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(r2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(r2, e4).enumerable;
    }))), n2.forEach(function(t3) {
      ye(e3, t3, r2[t3]);
    });
  }
  return e3;
}
var Oe = { itemType: null, item: null, sourceId: null, targetIds: [], dropResult: null, didDrop: false, isSourcePublic: null };
function we(e3 = Oe, t2) {
  const { payload: r2 } = t2;
  switch (t2.type) {
    case L:
      return be({}, e3, { itemType: r2.itemType, item: r2.item, sourceId: r2.sourceId, isSourcePublic: r2.isSourcePublic, dropResult: null, didDrop: false });
    case P:
      return be({}, e3, { isSourcePublic: true });
    case x:
      return be({}, e3, { targetIds: r2.targetIds });
    case ie:
      return -1 === e3.targetIds.indexOf(r2.targetId) ? e3 : be({}, e3, { targetIds: (n2 = e3.targetIds, o2 = r2.targetId, n2.filter((e4) => e4 !== o2)) });
    case M:
      return be({}, e3, { dropResult: r2.dropResult, didDrop: true, targetIds: [] });
    case N:
      return be({}, e3, { itemType: null, item: null, sourceId: null, dropResult: null, didDrop: false, isSourcePublic: null, targetIds: [] });
    default:
      return e3;
  }
  var n2, o2;
}
function Se(e3 = 0, t2) {
  switch (t2.type) {
    case re:
    case ne:
      return e3 + 1;
    case oe:
    case ie:
      return e3 - 1;
    default:
      return e3;
  }
}
function De(e3 = 0) {
  return e3 + 1;
}
function Ce(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
function Te(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {}, n2 = Object.keys(r2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(r2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(r2, e4).enumerable;
    }))), n2.forEach(function(t3) {
      Ce(e3, t3, r2[t3]);
    });
  }
  return e3;
}
function Ee(e3 = {}, t2) {
  return { dirtyHandlerIds: fe(e3.dirtyHandlerIds, { type: t2.type, payload: Te({}, t2.payload, { prevTargetIds: (r2 = e3, n2 = "dragOperation.targetIds", o2 = [], n2.split(".").reduce((e4, t3) => e4 && e4[t3] ? e4[t3] : o2 || null, r2)) }) }), dragOffset: me(e3.dragOffset, t2), refCount: Se(e3.refCount, t2), dragOperation: we(e3.dragOperation, t2), stateId: De(e3.stateId) };
  var r2, n2, o2;
}
function Ie(e3, t2 = void 0, r2 = {}, n2 = false) {
  const o2 = function(e4) {
    const t3 = "undefined" != typeof window && window.__REDUX_DEVTOOLS_EXTENSION__;
    return C(Ee, e4 && t3 && t3({ name: "dnd-core", instanceId: "dnd-core" }));
  }(n2), i2 = new K(o2, new he(o2)), s2 = new F(o2, i2), a2 = e3(s2, t2, r2);
  return s2.receiveBackend(a2), s2;
}
function ke(e3, t2) {
  if (null == e3)
    return {};
  var r2, n2, o2 = function(e4, t3) {
    if (null == e4)
      return {};
    var r3, n3, o3 = {}, i3 = Object.keys(e4);
    for (n3 = 0; n3 < i3.length; n3++)
      r3 = i3[n3], t3.indexOf(r3) >= 0 || (o3[r3] = e4[r3]);
    return o3;
  }(e3, t2);
  if (Object.getOwnPropertySymbols) {
    var i2 = Object.getOwnPropertySymbols(e3);
    for (n2 = 0; n2 < i2.length; n2++)
      r2 = i2[n2], t2.indexOf(r2) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, r2) && (o2[r2] = e3[r2]);
  }
  return o2;
}
var Le = 0;
var Pe = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var xe = (0, import_react.memo)(function(t2) {
  var { children: r2 } = t2, n2 = ke(t2, ["children"]);
  const [o2, s2] = function(e3) {
    if ("manager" in e3) {
      return [{ dragDropManager: e3.manager }, false];
    }
    const t3 = function(e4, t4 = Me(), r4, n3) {
      const o3 = t4;
      o3[Pe] || (o3[Pe] = { dragDropManager: Ie(e4, t4, r4, n3) });
      return o3[Pe];
    }(e3.backend, e3.context, e3.options, e3.debugMode), r3 = !e3.context;
    return [t3, r3];
  }(n2);
  return (0, import_react.useEffect)(() => {
    if (s2) {
      const e3 = Me();
      return ++Le, () => {
        0 == --Le && (e3[Pe] = null);
      };
    }
  }, []), (0, import_jsx_runtime.jsx)(m.Provider, { value: o2, children: r2 });
});
function Me() {
  return "undefined" != typeof global ? global : window;
}
var Ne = function e2(t2, r2) {
  if (t2 === r2)
    return true;
  if (t2 && r2 && "object" == typeof t2 && "object" == typeof r2) {
    if (t2.constructor !== r2.constructor)
      return false;
    var n2, o2, i2;
    if (Array.isArray(t2)) {
      if ((n2 = t2.length) != r2.length)
        return false;
      for (o2 = n2; 0 != o2--; )
        if (!e2(t2[o2], r2[o2]))
          return false;
      return true;
    }
    if (t2.constructor === RegExp)
      return t2.source === r2.source && t2.flags === r2.flags;
    if (t2.valueOf !== Object.prototype.valueOf)
      return t2.valueOf() === r2.valueOf();
    if (t2.toString !== Object.prototype.toString)
      return t2.toString() === r2.toString();
    if ((n2 = (i2 = Object.keys(t2)).length) !== Object.keys(r2).length)
      return false;
    for (o2 = n2; 0 != o2--; )
      if (!Object.prototype.hasOwnProperty.call(r2, i2[o2]))
        return false;
    for (o2 = n2; 0 != o2--; ) {
      var s2 = i2[o2];
      if (!e2(t2[s2], r2[s2]))
        return false;
    }
    return true;
  }
  return t2 != t2 && r2 != r2;
};
var je = "undefined" != typeof window ? import_react.useLayoutEffect : import_react.useEffect;
function Re(e3, t2, r2) {
  const [n2, o2] = (0, import_react.useState)(() => t2(e3)), i2 = (0, import_react.useCallback)(() => {
    const i3 = t2(e3);
    Ne(n2, i3) || (o2(i3), r2 && r2());
  }, [n2, e3, r2]);
  return je(i2), [n2, i2];
}
function Ae(e3, t2, r2) {
  return function(e4, t3, r3) {
    const [n2, o2] = Re(e4, t3, r3);
    return je(function() {
      const t4 = e4.getHandlerId();
      if (null != t4)
        return e4.subscribeToStateChange(o2, { handlerIds: [t4] });
    }, [e4, o2]), n2;
  }(t2, e3 || (() => ({})), () => r2.reconnect());
}
function qe(e3, t2) {
  const r2 = [...t2 || []];
  return null == t2 && "function" != typeof e3 && r2.push(e3), (0, import_react.useMemo)(() => "function" == typeof e3 ? e3() : e3, r2);
}
function _e(e3) {
  return (0, import_react.useMemo)(() => e3.hooks.dragSource(), [e3]);
}
function ze(e3) {
  return (0, import_react.useMemo)(() => e3.hooks.dragPreview(), [e3]);
}
var He = false;
var Be = false;
var We = class {
  receiveHandlerId(e3) {
    this.sourceId = e3;
  }
  getHandlerId() {
    return this.sourceId;
  }
  canDrag() {
    E(!He, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      return He = true, this.internalMonitor.canDragSource(this.sourceId);
    } finally {
      He = false;
    }
  }
  isDragging() {
    if (!this.sourceId)
      return false;
    E(!Be, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      return Be = true, this.internalMonitor.isDraggingSource(this.sourceId);
    } finally {
      Be = false;
    }
  }
  subscribeToStateChange(e3, t2) {
    return this.internalMonitor.subscribeToStateChange(e3, t2);
  }
  isDraggingSource(e3) {
    return this.internalMonitor.isDraggingSource(e3);
  }
  isOverTarget(e3, t2) {
    return this.internalMonitor.isOverTarget(e3, t2);
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds();
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic();
  }
  getSourceId() {
    return this.internalMonitor.getSourceId();
  }
  subscribeToOffsetChange(e3) {
    return this.internalMonitor.subscribeToOffsetChange(e3);
  }
  canDragSource(e3) {
    return this.internalMonitor.canDragSource(e3);
  }
  canDropOnTarget(e3) {
    return this.internalMonitor.canDropOnTarget(e3);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(e3) {
    this.sourceId = null, this.internalMonitor = e3.getMonitor();
  }
};
var Ue = false;
var Fe = class {
  receiveHandlerId(e3) {
    this.targetId = e3;
  }
  getHandlerId() {
    return this.targetId;
  }
  subscribeToStateChange(e3, t2) {
    return this.internalMonitor.subscribeToStateChange(e3, t2);
  }
  canDrop() {
    if (!this.targetId)
      return false;
    E(!Ue, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    try {
      return Ue = true, this.internalMonitor.canDropOnTarget(this.targetId);
    } finally {
      Ue = false;
    }
  }
  isOver(e3) {
    return !!this.targetId && this.internalMonitor.isOverTarget(this.targetId, e3);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(e3) {
    this.targetId = null, this.internalMonitor = e3.getMonitor();
  }
};
function $e(e3, t2, r2, n2) {
  let o2 = r2 ? r2.call(n2, e3, t2) : void 0;
  if (void 0 !== o2)
    return !!o2;
  if (e3 === t2)
    return true;
  if ("object" != typeof e3 || !e3 || "object" != typeof t2 || !t2)
    return false;
  const i2 = Object.keys(e3), s2 = Object.keys(t2);
  if (i2.length !== s2.length)
    return false;
  const a2 = Object.prototype.hasOwnProperty.bind(t2);
  for (let s3 = 0; s3 < i2.length; s3++) {
    const c2 = i2[s3];
    if (!a2(c2))
      return false;
    const u2 = e3[c2], l2 = t2[c2];
    if (o2 = r2 ? r2.call(n2, u2, l2, c2) : void 0, false === o2 || void 0 === o2 && u2 !== l2)
      return false;
  }
  return true;
}
function Ve(e3) {
  return null !== e3 && "object" == typeof e3 && Object.prototype.hasOwnProperty.call(e3, "current");
}
function Ye(e3) {
  return (t2 = null, r2 = null) => {
    if (!(0, import_react.isValidElement)(t2)) {
      const n3 = t2;
      return e3(n3, r2), n3;
    }
    const n2 = t2;
    !function(e4) {
      if ("string" == typeof e4.type)
        return;
      const t3 = e4.type.displayName || e4.type.name || "the component";
      throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t3} into a <div>, or turn it into a drag source or a drop target itself.`);
    }(n2);
    return function(e4, t3) {
      const r3 = e4.ref;
      return E("string" != typeof r3, "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"), (0, import_react.cloneElement)(e4, r3 ? { ref: (e5) => {
        Xe(r3, e5), Xe(t3, e5);
      } } : { ref: t3 });
    }(n2, r2 ? (t3) => e3(t3, r2) : e3);
  };
}
function Ke(e3) {
  const t2 = {};
  return Object.keys(e3).forEach((r2) => {
    const n2 = e3[r2];
    if (r2.endsWith("Ref"))
      t2[r2] = e3[r2];
    else {
      const e4 = Ye(n2);
      t2[r2] = () => e4;
    }
  }), t2;
}
function Xe(e3, t2) {
  "function" == typeof e3 ? e3(t2) : e3.current = t2;
}
var Ge = class {
  receiveHandlerId(e3) {
    this.handlerId !== e3 && (this.handlerId = e3, this.reconnect());
  }
  get connectTarget() {
    return this.dragSource;
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal;
  }
  set dragSourceOptions(e3) {
    this.dragSourceOptionsInternal = e3;
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal;
  }
  set dragPreviewOptions(e3) {
    this.dragPreviewOptionsInternal = e3;
  }
  reconnect() {
    const e3 = this.reconnectDragSource();
    this.reconnectDragPreview(e3);
  }
  reconnectDragSource() {
    const e3 = this.dragSource, t2 = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
    return t2 && this.disconnectDragSource(), this.handlerId ? e3 ? (t2 && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragSource = e3, this.lastConnectedDragSourceOptions = this.dragSourceOptions, this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, e3, this.dragSourceOptions)), t2) : (this.lastConnectedDragSource = e3, t2) : t2;
  }
  reconnectDragPreview(e3 = false) {
    const t2 = this.dragPreview, r2 = e3 || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
    r2 && this.disconnectDragPreview(), this.handlerId && (t2 ? r2 && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragPreview = t2, this.lastConnectedDragPreviewOptions = this.dragPreviewOptions, this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, t2, this.dragPreviewOptions)) : this.lastConnectedDragPreview = t2);
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource;
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview;
  }
  didDragSourceOptionsChange() {
    return !$e(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
  }
  didDragPreviewOptionsChange() {
    return !$e(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
  }
  disconnectDragSource() {
    this.dragSourceUnsubscribe && (this.dragSourceUnsubscribe(), this.dragSourceUnsubscribe = void 0);
  }
  disconnectDragPreview() {
    this.dragPreviewUnsubscribe && (this.dragPreviewUnsubscribe(), this.dragPreviewUnsubscribe = void 0, this.dragPreviewNode = null, this.dragPreviewRef = null);
  }
  get dragSource() {
    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
  }
  get dragPreview() {
    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
  }
  clearDragSource() {
    this.dragSourceNode = null, this.dragSourceRef = null;
  }
  clearDragPreview() {
    this.dragPreviewNode = null, this.dragPreviewRef = null;
  }
  constructor(e3) {
    this.hooks = Ke({ dragSource: (e4, t2) => {
      this.clearDragSource(), this.dragSourceOptions = t2 || null, Ve(e4) ? this.dragSourceRef = e4 : this.dragSourceNode = e4, this.reconnectDragSource();
    }, dragPreview: (e4, t2) => {
      this.clearDragPreview(), this.dragPreviewOptions = t2 || null, Ve(e4) ? this.dragPreviewRef = e4 : this.dragPreviewNode = e4, this.reconnectDragPreview();
    } }), this.handlerId = null, this.dragSourceRef = null, this.dragSourceOptionsInternal = null, this.dragPreviewRef = null, this.dragPreviewOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDragSource = null, this.lastConnectedDragSourceOptions = null, this.lastConnectedDragPreview = null, this.lastConnectedDragPreviewOptions = null, this.backend = e3;
  }
};
var Qe = class {
  get connectTarget() {
    return this.dropTarget;
  }
  reconnect() {
    const e3 = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
    e3 && this.disconnectDropTarget();
    const t2 = this.dropTarget;
    this.handlerId && (t2 ? e3 && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDropTarget = t2, this.lastConnectedDropTargetOptions = this.dropTargetOptions, this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, t2, this.dropTargetOptions)) : this.lastConnectedDropTarget = t2);
  }
  receiveHandlerId(e3) {
    e3 !== this.handlerId && (this.handlerId = e3, this.reconnect());
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal;
  }
  set dropTargetOptions(e3) {
    this.dropTargetOptionsInternal = e3;
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget;
  }
  didOptionsChange() {
    return !$e(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
  }
  disconnectDropTarget() {
    this.unsubscribeDropTarget && (this.unsubscribeDropTarget(), this.unsubscribeDropTarget = void 0);
  }
  get dropTarget() {
    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
  }
  clearDropTarget() {
    this.dropTargetRef = null, this.dropTargetNode = null;
  }
  constructor(e3) {
    this.hooks = Ke({ dropTarget: (e4, t2) => {
      this.clearDropTarget(), this.dropTargetOptions = t2, Ve(e4) ? this.dropTargetRef = e4 : this.dropTargetNode = e4, this.reconnect();
    } }), this.handlerId = null, this.dropTargetRef = null, this.dropTargetOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDropTarget = null, this.lastConnectedDropTargetOptions = null, this.backend = e3;
  }
};
function Je() {
  const { dragDropManager: e3 } = (0, import_react.useContext)(m);
  return E(null != e3, "Expected drag drop context"), e3;
}
var Ze = class {
  beginDrag() {
    const e3 = this.spec, t2 = this.monitor;
    let r2 = null;
    return r2 = "object" == typeof e3.item ? e3.item : "function" == typeof e3.item ? e3.item(t2) : {}, null != r2 ? r2 : null;
  }
  canDrag() {
    const e3 = this.spec, t2 = this.monitor;
    return "boolean" == typeof e3.canDrag ? e3.canDrag : "function" != typeof e3.canDrag || e3.canDrag(t2);
  }
  isDragging(e3, t2) {
    const r2 = this.spec, n2 = this.monitor, { isDragging: o2 } = r2;
    return o2 ? o2(n2) : t2 === e3.getSourceId();
  }
  endDrag() {
    const e3 = this.spec, t2 = this.monitor, r2 = this.connector, { end: n2 } = e3;
    n2 && n2(t2.getItem(), t2), r2.reconnect();
  }
  constructor(e3, t2, r2) {
    this.spec = e3, this.monitor = t2, this.connector = r2;
  }
};
function et(e3, t2, r2) {
  const n2 = Je(), o2 = function(e4, t3, r3) {
    const n3 = (0, import_react.useMemo)(() => new Ze(e4, t3, r3), [t3, r3]);
    return (0, import_react.useEffect)(() => {
      n3.spec = e4;
    }, [e4]), n3;
  }(e3, t2, r2), s2 = function(e4) {
    return (0, import_react.useMemo)(() => {
      const t3 = e4.type;
      return E(null != t3, "spec.type must be defined"), t3;
    }, [e4]);
  }(e3);
  je(function() {
    if (null != s2) {
      const [e4, i2] = function(e5, t3, r3) {
        const n3 = r3.getRegistry(), o3 = n3.addSource(e5, t3);
        return [o3, () => n3.removeSource(o3)];
      }(s2, o2, n2);
      return t2.receiveHandlerId(e4), r2.receiveHandlerId(e4), i2;
    }
  }, [n2, t2, r2, o2, s2]);
}
function tt(e3, t2) {
  const r2 = qe(e3, t2);
  E(!r2.begin, "useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");
  const n2 = function() {
    const e4 = Je();
    return (0, import_react.useMemo)(() => new We(e4), [e4]);
  }(), o2 = function(e4, t3) {
    const r3 = Je(), n3 = (0, import_react.useMemo)(() => new Ge(r3.getBackend()), [r3]);
    return je(() => (n3.dragSourceOptions = e4 || null, n3.reconnect(), () => n3.disconnectDragSource()), [n3, e4]), je(() => (n3.dragPreviewOptions = t3 || null, n3.reconnect(), () => n3.disconnectDragPreview()), [n3, t3]), n3;
  }(r2.options, r2.previewOptions);
  return et(r2, n2, o2), [Ae(r2.collect, n2, o2), _e(o2), ze(o2)];
}
function rt(e3) {
  return (0, import_react.useMemo)(() => e3.hooks.dropTarget(), [e3]);
}
var nt = class {
  canDrop() {
    const e3 = this.spec, t2 = this.monitor;
    return !e3.canDrop || e3.canDrop(t2.getItem(), t2);
  }
  hover() {
    const e3 = this.spec, t2 = this.monitor;
    e3.hover && e3.hover(t2.getItem(), t2);
  }
  drop() {
    const e3 = this.spec, t2 = this.monitor;
    if (e3.drop)
      return e3.drop(t2.getItem(), t2);
  }
  constructor(e3, t2) {
    this.spec = e3, this.monitor = t2;
  }
};
function ot(e3, t2, r2) {
  const n2 = Je(), o2 = function(e4, t3) {
    const r3 = (0, import_react.useMemo)(() => new nt(e4, t3), [t3]);
    return (0, import_react.useEffect)(() => {
      r3.spec = e4;
    }, [e4]), r3;
  }(e3, t2), s2 = function(e4) {
    const { accept: t3 } = e4;
    return (0, import_react.useMemo)(() => (E(null != e4.accept, "accept must be defined"), Array.isArray(t3) ? t3 : [t3]), [t3]);
  }(e3);
  je(function() {
    const [e4, i2] = function(e5, t3, r3) {
      const n3 = r3.getRegistry(), o3 = n3.addTarget(e5, t3);
      return [o3, () => n3.removeTarget(o3)];
    }(s2, o2, n2);
    return t2.receiveHandlerId(e4), r2.receiveHandlerId(e4), i2;
  }, [n2, t2, o2, r2, s2.map((e4) => e4.toString()).join("|")]);
}
function it(e3, t2) {
  const r2 = qe(e3, t2), n2 = function() {
    const e4 = Je();
    return (0, import_react.useMemo)(() => new Fe(e4), [e4]);
  }(), o2 = function(e4) {
    const t3 = Je(), r3 = (0, import_react.useMemo)(() => new Qe(t3.getBackend()), [t3]);
    return je(() => (r3.dropTargetOptions = e4 || null, r3.reconnect(), () => r3.disconnectDropTarget()), [e4]), r3;
  }(r2.options);
  return ot(r2, n2, o2), [Ae(r2.collect, n2, o2), rt(o2)];
}
function st(e3) {
  let t2 = null;
  return () => (null == t2 && (t2 = e3()), t2);
}
var at = class {
  enter(e3) {
    const t2 = this.entered.length;
    return this.entered = function(e4, t3) {
      const r2 = /* @__PURE__ */ new Set(), n2 = (e5) => r2.add(e5);
      e4.forEach(n2), t3.forEach(n2);
      const o2 = [];
      return r2.forEach((e5) => o2.push(e5)), o2;
    }(this.entered.filter((t3) => this.isNodeInDocument(t3) && (!t3.contains || t3.contains(e3))), [e3]), 0 === t2 && this.entered.length > 0;
  }
  leave(e3) {
    const t2 = this.entered.length;
    var r2, n2;
    return this.entered = (r2 = this.entered.filter(this.isNodeInDocument), n2 = e3, r2.filter((e4) => e4 !== n2)), t2 > 0 && 0 === this.entered.length;
  }
  reset() {
    this.entered = [];
  }
  constructor(e3) {
    this.entered = [], this.isNodeInDocument = e3;
  }
};
var ct = class {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((e3) => {
      Object.defineProperty(this.item, e3, { configurable: true, enumerable: true, get: () => (console.warn(`Browser doesn't allow reading "${e3}" until the drop event.`), null) });
    });
  }
  loadDataTransfer(e3) {
    if (e3) {
      const t2 = {};
      Object.keys(this.config.exposeProperties).forEach((r2) => {
        const n2 = this.config.exposeProperties[r2];
        null != n2 && (t2[r2] = { value: n2(e3, this.config.matchesTypes), configurable: true, enumerable: true });
      }), Object.defineProperties(this.item, t2);
    }
  }
  canDrag() {
    return true;
  }
  beginDrag() {
    return this.item;
  }
  isDragging(e3, t2) {
    return t2 === e3.getSourceId();
  }
  endDrag() {
  }
  constructor(e3) {
    this.config = e3, this.item = {}, this.initializeExposedProperties();
  }
};
var ut = "__NATIVE_FILE__";
var lt = "__NATIVE_URL__";
var dt = "__NATIVE_TEXT__";
var ht = "__NATIVE_HTML__";
var gt = Object.freeze({ __proto__: null, FILE: ut, HTML: ht, TEXT: dt, URL: lt });
function ft(e3, t2, r2) {
  const n2 = t2.reduce((t3, r3) => t3 || e3.getData(r3), "");
  return null != n2 ? n2 : r2;
}
var pt = { [ut]: { exposeProperties: { files: (e3) => Array.prototype.slice.call(e3.files), items: (e3) => e3.items, dataTransfer: (e3) => e3 }, matchesTypes: ["Files"] }, [ht]: { exposeProperties: { html: (e3, t2) => ft(e3, t2, ""), dataTransfer: (e3) => e3 }, matchesTypes: ["Html", "text/html"] }, [lt]: { exposeProperties: { urls: (e3, t2) => ft(e3, t2, "").split("\n"), dataTransfer: (e3) => e3 }, matchesTypes: ["Url", "text/uri-list"] }, [dt]: { exposeProperties: { text: (e3, t2) => ft(e3, t2, ""), dataTransfer: (e3) => e3 }, matchesTypes: ["Text", "text/plain"] } };
function vt(e3) {
  if (!e3)
    return null;
  const t2 = Array.prototype.slice.call(e3.types || []);
  return Object.keys(pt).filter((e4) => {
    const r2 = pt[e4];
    return !!(null == r2 ? void 0 : r2.matchesTypes) && r2.matchesTypes.some((e5) => t2.indexOf(e5) > -1);
  })[0] || null;
}
var mt = st(() => /firefox/i.test(navigator.userAgent));
var yt = st(() => Boolean(window.safari));
var bt = class {
  interpolate(e3) {
    const { xs: t2, ys: r2, c1s: n2, c2s: o2, c3s: i2 } = this;
    let s2 = t2.length - 1;
    if (e3 === t2[s2])
      return r2[s2];
    let a2, c2 = 0, u2 = i2.length - 1;
    for (; c2 <= u2; ) {
      a2 = Math.floor(0.5 * (c2 + u2));
      const n3 = t2[a2];
      if (n3 < e3)
        c2 = a2 + 1;
      else {
        if (!(n3 > e3))
          return r2[a2];
        u2 = a2 - 1;
      }
    }
    s2 = Math.max(0, u2);
    const l2 = e3 - t2[s2], d2 = l2 * l2;
    return r2[s2] + n2[s2] * l2 + o2[s2] * d2 + i2[s2] * l2 * d2;
  }
  constructor(e3, t2) {
    const { length: r2 } = e3, n2 = [];
    for (let e4 = 0; e4 < r2; e4++)
      n2.push(e4);
    n2.sort((t3, r3) => e3[t3] < e3[r3] ? -1 : 1);
    const o2 = [], i2 = [];
    let s2, a2;
    for (let n3 = 0; n3 < r2 - 1; n3++)
      s2 = e3[n3 + 1] - e3[n3], a2 = t2[n3 + 1] - t2[n3], o2.push(s2), i2.push(a2 / s2);
    const c2 = [i2[0]];
    for (let e4 = 0; e4 < o2.length - 1; e4++) {
      const t3 = i2[e4], r3 = i2[e4 + 1];
      if (t3 * r3 <= 0)
        c2.push(0);
      else {
        s2 = o2[e4];
        const n3 = o2[e4 + 1], i3 = s2 + n3;
        c2.push(3 * i3 / ((i3 + n3) / t3 + (i3 + s2) / r3));
      }
    }
    c2.push(i2[i2.length - 1]);
    const u2 = [], l2 = [];
    let d2;
    for (let e4 = 0; e4 < c2.length - 1; e4++) {
      d2 = i2[e4];
      const t3 = c2[e4], r3 = 1 / o2[e4], n3 = t3 + c2[e4 + 1] - d2 - d2;
      u2.push((d2 - t3 - n3) * r3), l2.push(n3 * r3 * r3);
    }
    this.xs = e3, this.ys = t2, this.c1s = c2, this.c2s = u2, this.c3s = l2;
  }
};
var Ot = 1;
function wt(e3) {
  const t2 = e3.nodeType === Ot ? e3 : e3.parentElement;
  if (!t2)
    return null;
  const { top: r2, left: n2 } = t2.getBoundingClientRect();
  return { x: n2, y: r2 };
}
function St(e3) {
  return { x: e3.clientX, y: e3.clientY };
}
function Dt(e3, t2, r2, n2, o2) {
  const i2 = "IMG" === (s2 = t2).nodeName && (mt() || !(null === (a2 = document.documentElement) || void 0 === a2 ? void 0 : a2.contains(s2)));
  var s2, a2;
  const c2 = wt(i2 ? e3 : t2), u2 = { x: r2.x - c2.x, y: r2.y - c2.y }, { offsetWidth: l2, offsetHeight: d2 } = e3, { anchorX: h2, anchorY: g2 } = n2, { dragPreviewWidth: f2, dragPreviewHeight: p2 } = function(e4, t3, r3, n3) {
    let o3 = e4 ? t3.width : r3, i3 = e4 ? t3.height : n3;
    return yt() && e4 && (i3 /= window.devicePixelRatio, o3 /= window.devicePixelRatio), { dragPreviewWidth: o3, dragPreviewHeight: i3 };
  }(i2, t2, l2, d2), { offsetX: v2, offsetY: m2 } = o2, y = 0 === m2 || m2;
  return { x: 0 === v2 || v2 ? v2 : new bt([0, 0.5, 1], [u2.x, u2.x / l2 * f2, u2.x + f2 - l2]).interpolate(h2), y: y ? m2 : (() => {
    let e4 = new bt([0, 0.5, 1], [u2.y, u2.y / d2 * p2, u2.y + p2 - d2]).interpolate(g2);
    return yt() && i2 && (e4 += (window.devicePixelRatio - 1) * p2), e4;
  })() };
}
var Ct;
function Tt(e3, t2, r2) {
  return t2 in e3 ? Object.defineProperty(e3, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t2] = r2, e3;
}
function Et(e3) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var r2 = null != arguments[t2] ? arguments[t2] : {}, n2 = Object.keys(r2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(r2).filter(function(e4) {
      return Object.getOwnPropertyDescriptor(r2, e4).enumerable;
    }))), n2.forEach(function(t3) {
      Tt(e3, t3, r2[t3]);
    });
  }
  return e3;
}
var It = class {
  profile() {
    var e3, t2;
    return { sourcePreviewNodes: this.sourcePreviewNodes.size, sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size, sourceNodeOptions: this.sourceNodeOptions.size, sourceNodes: this.sourceNodes.size, dragStartSourceIds: (null === (e3 = this.dragStartSourceIds) || void 0 === e3 ? void 0 : e3.length) || 0, dropTargetIds: this.dropTargetIds.length, dragEnterTargetIds: this.dragEnterTargetIds.length, dragOverTargetIds: (null === (t2 = this.dragOverTargetIds) || void 0 === t2 ? void 0 : t2.length) || 0 };
  }
  get window() {
    return this.options.window;
  }
  get document() {
    return this.options.document;
  }
  get rootElement() {
    return this.options.rootElement;
  }
  setup() {
    const e3 = this.rootElement;
    if (void 0 !== e3) {
      if (e3.__isReactDndBackendSetUp)
        throw new Error("Cannot have two HTML5 backends at the same time.");
      e3.__isReactDndBackendSetUp = true, this.addEventListeners(e3);
    }
  }
  teardown() {
    const e3 = this.rootElement;
    var t2;
    void 0 !== e3 && (e3.__isReactDndBackendSetUp = false, this.removeEventListeners(this.rootElement), this.clearCurrentDragSourceNode(), this.asyncEndDragFrameId && (null === (t2 = this.window) || void 0 === t2 || t2.cancelAnimationFrame(this.asyncEndDragFrameId)));
  }
  connectDragPreview(e3, t2, r2) {
    return this.sourcePreviewNodeOptions.set(e3, r2), this.sourcePreviewNodes.set(e3, t2), () => {
      this.sourcePreviewNodes.delete(e3), this.sourcePreviewNodeOptions.delete(e3);
    };
  }
  connectDragSource(e3, t2, r2) {
    this.sourceNodes.set(e3, t2), this.sourceNodeOptions.set(e3, r2);
    const n2 = (t3) => this.handleDragStart(t3, e3), o2 = (e4) => this.handleSelectStart(e4);
    return t2.setAttribute("draggable", "true"), t2.addEventListener("dragstart", n2), t2.addEventListener("selectstart", o2), () => {
      this.sourceNodes.delete(e3), this.sourceNodeOptions.delete(e3), t2.removeEventListener("dragstart", n2), t2.removeEventListener("selectstart", o2), t2.setAttribute("draggable", "false");
    };
  }
  connectDropTarget(e3, t2) {
    const r2 = (t3) => this.handleDragEnter(t3, e3), n2 = (t3) => this.handleDragOver(t3, e3), o2 = (t3) => this.handleDrop(t3, e3);
    return t2.addEventListener("dragenter", r2), t2.addEventListener("dragover", n2), t2.addEventListener("drop", o2), () => {
      t2.removeEventListener("dragenter", r2), t2.removeEventListener("dragover", n2), t2.removeEventListener("drop", o2);
    };
  }
  addEventListeners(e3) {
    e3.addEventListener && (e3.addEventListener("dragstart", this.handleTopDragStart), e3.addEventListener("dragstart", this.handleTopDragStartCapture, true), e3.addEventListener("dragend", this.handleTopDragEndCapture, true), e3.addEventListener("dragenter", this.handleTopDragEnter), e3.addEventListener("dragenter", this.handleTopDragEnterCapture, true), e3.addEventListener("dragleave", this.handleTopDragLeaveCapture, true), e3.addEventListener("dragover", this.handleTopDragOver), e3.addEventListener("dragover", this.handleTopDragOverCapture, true), e3.addEventListener("drop", this.handleTopDrop), e3.addEventListener("drop", this.handleTopDropCapture, true));
  }
  removeEventListeners(e3) {
    e3.removeEventListener && (e3.removeEventListener("dragstart", this.handleTopDragStart), e3.removeEventListener("dragstart", this.handleTopDragStartCapture, true), e3.removeEventListener("dragend", this.handleTopDragEndCapture, true), e3.removeEventListener("dragenter", this.handleTopDragEnter), e3.removeEventListener("dragenter", this.handleTopDragEnterCapture, true), e3.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true), e3.removeEventListener("dragover", this.handleTopDragOver), e3.removeEventListener("dragover", this.handleTopDragOverCapture, true), e3.removeEventListener("drop", this.handleTopDrop), e3.removeEventListener("drop", this.handleTopDropCapture, true));
  }
  getCurrentSourceNodeOptions() {
    const e3 = this.monitor.getSourceId(), t2 = this.sourceNodeOptions.get(e3);
    return Et({ dropEffect: this.altKeyPressed ? "copy" : "move" }, t2 || {});
  }
  getCurrentDropEffect() {
    return this.isDraggingNativeItem() ? "copy" : this.getCurrentSourceNodeOptions().dropEffect;
  }
  getCurrentSourcePreviewNodeOptions() {
    const e3 = this.monitor.getSourceId();
    return Et({ anchorX: 0.5, anchorY: 0.5, captureDraggingState: false }, this.sourcePreviewNodeOptions.get(e3) || {});
  }
  isDraggingNativeItem() {
    const e3 = this.monitor.getItemType();
    return Object.keys(gt).some((t2) => gt[t2] === e3);
  }
  beginDragNativeItem(e3, t2) {
    this.clearCurrentDragSourceNode(), this.currentNativeSource = function(e4, t3) {
      const r2 = pt[e4];
      if (!r2)
        throw new Error(`native type ${e4} has no configuration`);
      const n2 = new ct(r2);
      return n2.loadDataTransfer(t3), n2;
    }(e3, t2), this.currentNativeHandle = this.registry.addSource(e3, this.currentNativeSource), this.actions.beginDrag([this.currentNativeHandle]);
  }
  setCurrentDragSourceNode(e3) {
    this.clearCurrentDragSourceNode(), this.currentDragSourceNode = e3;
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var e4;
      return null === (e4 = this.rootElement) || void 0 === e4 ? void 0 : e4.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
    }, 1e3);
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      var e3;
      if (this.currentDragSourceNode = null, this.rootElement)
        null === (e3 = this.window) || void 0 === e3 || e3.clearTimeout(this.mouseMoveTimeoutTimer || void 0), this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
      return this.mouseMoveTimeoutTimer = null, true;
    }
    return false;
  }
  handleDragStart(e3, t2) {
    e3.defaultPrevented || (this.dragStartSourceIds || (this.dragStartSourceIds = []), this.dragStartSourceIds.unshift(t2));
  }
  handleDragEnter(e3, t2) {
    this.dragEnterTargetIds.unshift(t2);
  }
  handleDragOver(e3, t2) {
    null === this.dragOverTargetIds && (this.dragOverTargetIds = []), this.dragOverTargetIds.unshift(t2);
  }
  handleDrop(e3, t2) {
    this.dropTargetIds.unshift(t2);
  }
  constructor(e3, t2, r2) {
    this.sourcePreviewNodes = /* @__PURE__ */ new Map(), this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map(), this.sourceNodes = /* @__PURE__ */ new Map(), this.sourceNodeOptions = /* @__PURE__ */ new Map(), this.dragStartSourceIds = null, this.dropTargetIds = [], this.dragEnterTargetIds = [], this.currentNativeSource = null, this.currentNativeHandle = null, this.currentDragSourceNode = null, this.altKeyPressed = false, this.mouseMoveTimeoutTimer = null, this.asyncEndDragFrameId = null, this.dragOverTargetIds = null, this.lastClientOffset = null, this.hoverRafId = null, this.getSourceClientOffset = (e4) => {
      const t3 = this.sourceNodes.get(e4);
      return t3 && wt(t3) || null;
    }, this.endDragNativeItem = () => {
      this.isDraggingNativeItem() && (this.actions.endDrag(), this.currentNativeHandle && this.registry.removeSource(this.currentNativeHandle), this.currentNativeHandle = null, this.currentNativeSource = null);
    }, this.isNodeInDocument = (e4) => Boolean(e4 && this.document && this.document.body && this.document.body.contains(e4)), this.endDragIfSourceWasRemovedFromDOM = () => {
      const e4 = this.currentDragSourceNode;
      null == e4 || this.isNodeInDocument(e4) || (this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover());
    }, this.scheduleHover = (e4) => {
      null === this.hoverRafId && "undefined" != typeof requestAnimationFrame && (this.hoverRafId = requestAnimationFrame(() => {
        this.monitor.isDragging() && this.actions.hover(e4 || [], { clientOffset: this.lastClientOffset }), this.hoverRafId = null;
      }));
    }, this.cancelHover = () => {
      null !== this.hoverRafId && "undefined" != typeof cancelAnimationFrame && (cancelAnimationFrame(this.hoverRafId), this.hoverRafId = null);
    }, this.handleTopDragStartCapture = () => {
      this.clearCurrentDragSourceNode(), this.dragStartSourceIds = [];
    }, this.handleTopDragStart = (e4) => {
      if (e4.defaultPrevented)
        return;
      const { dragStartSourceIds: t3 } = this;
      this.dragStartSourceIds = null;
      const r3 = St(e4);
      this.monitor.isDragging() && (this.actions.endDrag(), this.cancelHover()), this.actions.beginDrag(t3 || [], { publishSource: false, getSourceClientOffset: this.getSourceClientOffset, clientOffset: r3 });
      const { dataTransfer: n2 } = e4, o2 = vt(n2);
      if (this.monitor.isDragging()) {
        if (n2 && "function" == typeof n2.setDragImage) {
          const e5 = this.monitor.getSourceId(), t5 = this.sourceNodes.get(e5), o3 = this.sourcePreviewNodes.get(e5) || t5;
          if (o3) {
            const { anchorX: e6, anchorY: i2, offsetX: s2, offsetY: a2 } = this.getCurrentSourcePreviewNodeOptions(), c2 = Dt(t5, o3, r3, { anchorX: e6, anchorY: i2 }, { offsetX: s2, offsetY: a2 });
            n2.setDragImage(o3, c2.x, c2.y);
          }
        }
        try {
          null == n2 || n2.setData("application/json", {});
        } catch (e5) {
        }
        this.setCurrentDragSourceNode(e4.target);
        const { captureDraggingState: t4 } = this.getCurrentSourcePreviewNodeOptions();
        t4 ? this.actions.publishDragSource() : setTimeout(() => this.actions.publishDragSource(), 0);
      } else if (o2)
        this.beginDragNativeItem(o2);
      else {
        if (n2 && !n2.types && (e4.target && !e4.target.hasAttribute || !e4.target.hasAttribute("draggable")))
          return;
        e4.preventDefault();
      }
    }, this.handleTopDragEndCapture = () => {
      this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover();
    }, this.handleTopDragEnterCapture = (e4) => {
      var t3;
      (this.dragEnterTargetIds = [], this.isDraggingNativeItem()) && (null === (t3 = this.currentNativeSource) || void 0 === t3 || t3.loadDataTransfer(e4.dataTransfer));
      if (!this.enterLeaveCounter.enter(e4.target) || this.monitor.isDragging())
        return;
      const { dataTransfer: r3 } = e4, n2 = vt(r3);
      n2 && this.beginDragNativeItem(n2, r3);
    }, this.handleTopDragEnter = (e4) => {
      const { dragEnterTargetIds: t3 } = this;
      if (this.dragEnterTargetIds = [], !this.monitor.isDragging())
        return;
      this.altKeyPressed = e4.altKey, t3.length > 0 && this.actions.hover(t3, { clientOffset: St(e4) });
      t3.some((e5) => this.monitor.canDropOnTarget(e5)) && (e4.preventDefault(), e4.dataTransfer && (e4.dataTransfer.dropEffect = this.getCurrentDropEffect()));
    }, this.handleTopDragOverCapture = (e4) => {
      var t3;
      (this.dragOverTargetIds = [], this.isDraggingNativeItem()) && (null === (t3 = this.currentNativeSource) || void 0 === t3 || t3.loadDataTransfer(e4.dataTransfer));
    }, this.handleTopDragOver = (e4) => {
      const { dragOverTargetIds: t3 } = this;
      if (this.dragOverTargetIds = [], !this.monitor.isDragging())
        return e4.preventDefault(), void (e4.dataTransfer && (e4.dataTransfer.dropEffect = "none"));
      this.altKeyPressed = e4.altKey, this.lastClientOffset = St(e4), this.scheduleHover(t3);
      (t3 || []).some((e5) => this.monitor.canDropOnTarget(e5)) ? (e4.preventDefault(), e4.dataTransfer && (e4.dataTransfer.dropEffect = this.getCurrentDropEffect())) : this.isDraggingNativeItem() ? e4.preventDefault() : (e4.preventDefault(), e4.dataTransfer && (e4.dataTransfer.dropEffect = "none"));
    }, this.handleTopDragLeaveCapture = (e4) => {
      this.isDraggingNativeItem() && e4.preventDefault();
      this.enterLeaveCounter.leave(e4.target) && (this.isDraggingNativeItem() && setTimeout(() => this.endDragNativeItem(), 0), this.cancelHover());
    }, this.handleTopDropCapture = (e4) => {
      var t3;
      (this.dropTargetIds = [], this.isDraggingNativeItem()) ? (e4.preventDefault(), null === (t3 = this.currentNativeSource) || void 0 === t3 || t3.loadDataTransfer(e4.dataTransfer)) : vt(e4.dataTransfer) && e4.preventDefault();
      this.enterLeaveCounter.reset();
    }, this.handleTopDrop = (e4) => {
      const { dropTargetIds: t3 } = this;
      this.dropTargetIds = [], this.actions.hover(t3, { clientOffset: St(e4) }), this.actions.drop({ dropEffect: this.getCurrentDropEffect() }), this.isDraggingNativeItem() ? this.endDragNativeItem() : this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover();
    }, this.handleSelectStart = (e4) => {
      const t3 = e4.target;
      "function" == typeof t3.dragDrop && ("INPUT" === t3.tagName || "SELECT" === t3.tagName || "TEXTAREA" === t3.tagName || t3.isContentEditable || (e4.preventDefault(), t3.dragDrop()));
    }, this.options = new class {
      get window() {
        return this.globalContext ? this.globalContext : "undefined" != typeof window ? window : void 0;
      }
      get document() {
        var e4;
        return (null === (e4 = this.globalContext) || void 0 === e4 ? void 0 : e4.document) ? this.globalContext.document : this.window ? this.window.document : void 0;
      }
      get rootElement() {
        var e4;
        return (null === (e4 = this.optionsArgs) || void 0 === e4 ? void 0 : e4.rootElement) || this.window;
      }
      constructor(e4, t3) {
        this.ownerDocument = null, this.globalContext = e4, this.optionsArgs = t3;
      }
    }(t2, r2), this.actions = e3.getActions(), this.monitor = e3.getMonitor(), this.registry = e3.getRegistry(), this.enterLeaveCounter = new at(this.isNodeInDocument);
  }
};
var kt = function(e3, t2, r2) {
  return new It(e3, t2, r2);
};
var Lt;
!function(e3) {
  e3.mouse = "mouse", e3.touch = "touch", e3.keyboard = "keyboard";
}(Lt || (Lt = {}));
var Pt = class {
  get delay() {
    var e3;
    return null !== (e3 = this.args.delay) && void 0 !== e3 ? e3 : 0;
  }
  get scrollAngleRanges() {
    return this.args.scrollAngleRanges;
  }
  get getDropTargetElementsAtPoint() {
    return this.args.getDropTargetElementsAtPoint;
  }
  get ignoreContextMenu() {
    var e3;
    return null !== (e3 = this.args.ignoreContextMenu) && void 0 !== e3 && e3;
  }
  get enableHoverOutsideTarget() {
    var e3;
    return null !== (e3 = this.args.enableHoverOutsideTarget) && void 0 !== e3 && e3;
  }
  get enableKeyboardEvents() {
    var e3;
    return null !== (e3 = this.args.enableKeyboardEvents) && void 0 !== e3 && e3;
  }
  get enableMouseEvents() {
    var e3;
    return null !== (e3 = this.args.enableMouseEvents) && void 0 !== e3 && e3;
  }
  get enableTouchEvents() {
    var e3;
    return null === (e3 = this.args.enableTouchEvents) || void 0 === e3 || e3;
  }
  get touchSlop() {
    return this.args.touchSlop || 0;
  }
  get delayTouchStart() {
    var e3, t2, r2, n2;
    return null !== (n2 = null !== (r2 = null === (e3 = this.args) || void 0 === e3 ? void 0 : e3.delayTouchStart) && void 0 !== r2 ? r2 : null === (t2 = this.args) || void 0 === t2 ? void 0 : t2.delay) && void 0 !== n2 ? n2 : 0;
  }
  get delayMouseStart() {
    var e3, t2, r2, n2;
    return null !== (n2 = null !== (r2 = null === (e3 = this.args) || void 0 === e3 ? void 0 : e3.delayMouseStart) && void 0 !== r2 ? r2 : null === (t2 = this.args) || void 0 === t2 ? void 0 : t2.delay) && void 0 !== n2 ? n2 : 0;
  }
  get window() {
    return this.context && this.context.window ? this.context.window : "undefined" != typeof window ? window : void 0;
  }
  get document() {
    var e3;
    return (null === (e3 = this.context) || void 0 === e3 ? void 0 : e3.document) ? this.context.document : this.window ? this.window.document : void 0;
  }
  get rootElement() {
    var e3;
    return (null === (e3 = this.args) || void 0 === e3 ? void 0 : e3.rootElement) || this.document;
  }
  constructor(e3, t2) {
    this.args = e3, this.context = t2;
  }
};
var xt = 1;
var Mt = 0;
function Nt(e3) {
  return void 0 === e3.button || e3.button === Mt;
}
function jt(e3) {
  return !!e3.targetTouches;
}
function Rt(e3, t2) {
  return jt(e3) ? function(e4, t3) {
    return 1 === e4.targetTouches.length ? Rt(e4.targetTouches[0]) : t3 && 1 === e4.touches.length && e4.touches[0].target === t3.target ? Rt(e4.touches[0]) : void 0;
  }(e3, t2) : { x: e3.clientX, y: e3.clientY };
}
var At = (() => {
  let e3 = false;
  try {
    addEventListener("test", () => {
    }, Object.defineProperty({}, "passive", { get: () => (e3 = true, true) }));
  } catch (e4) {
  }
  return e3;
})();
var qt = { [Lt.mouse]: { start: "mousedown", move: "mousemove", end: "mouseup", contextmenu: "contextmenu" }, [Lt.touch]: { start: "touchstart", move: "touchmove", end: "touchend" }, [Lt.keyboard]: { keydown: "keydown" } };
var _t = class __t {
  profile() {
    var e3;
    return { sourceNodes: this.sourceNodes.size, sourcePreviewNodes: this.sourcePreviewNodes.size, sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size, targetNodes: this.targetNodes.size, dragOverTargetIds: (null === (e3 = this.dragOverTargetIds) || void 0 === e3 ? void 0 : e3.length) || 0 };
  }
  get document() {
    return this.options.document;
  }
  setup() {
    const e3 = this.options.rootElement;
    e3 && (E(!__t.isSetUp, "Cannot have two Touch backends at the same time."), __t.isSetUp = true, this.addEventListener(e3, "start", this.getTopMoveStartHandler()), this.addEventListener(e3, "start", this.handleTopMoveStartCapture, true), this.addEventListener(e3, "move", this.handleTopMove), this.addEventListener(e3, "move", this.handleTopMoveCapture, true), this.addEventListener(e3, "end", this.handleTopMoveEndCapture, true), this.options.enableMouseEvents && !this.options.ignoreContextMenu && this.addEventListener(e3, "contextmenu", this.handleTopMoveEndCapture), this.options.enableKeyboardEvents && this.addEventListener(e3, "keydown", this.handleCancelOnEscape, true));
  }
  teardown() {
    const e3 = this.options.rootElement;
    e3 && (__t.isSetUp = false, this._mouseClientOffset = {}, this.removeEventListener(e3, "start", this.handleTopMoveStartCapture, true), this.removeEventListener(e3, "start", this.handleTopMoveStart), this.removeEventListener(e3, "move", this.handleTopMoveCapture, true), this.removeEventListener(e3, "move", this.handleTopMove), this.removeEventListener(e3, "end", this.handleTopMoveEndCapture, true), this.options.enableMouseEvents && !this.options.ignoreContextMenu && this.removeEventListener(e3, "contextmenu", this.handleTopMoveEndCapture), this.options.enableKeyboardEvents && this.removeEventListener(e3, "keydown", this.handleCancelOnEscape, true), this.uninstallSourceNodeRemovalObserver());
  }
  addEventListener(e3, t2, r2, n2 = false) {
    const o2 = At ? { capture: n2, passive: false } : n2;
    this.listenerTypes.forEach(function(n3) {
      const i2 = qt[n3][t2];
      i2 && e3.addEventListener(i2, r2, o2);
    });
  }
  removeEventListener(e3, t2, r2, n2 = false) {
    const o2 = At ? { capture: n2, passive: false } : n2;
    this.listenerTypes.forEach(function(n3) {
      const i2 = qt[n3][t2];
      i2 && e3.removeEventListener(i2, r2, o2);
    });
  }
  connectDragSource(e3, t2) {
    const r2 = this.handleMoveStart.bind(this, e3);
    return this.sourceNodes.set(e3, t2), this.addEventListener(t2, "start", r2), () => {
      this.sourceNodes.delete(e3), this.removeEventListener(t2, "start", r2);
    };
  }
  connectDragPreview(e3, t2, r2) {
    return this.sourcePreviewNodeOptions.set(e3, r2), this.sourcePreviewNodes.set(e3, t2), () => {
      this.sourcePreviewNodes.delete(e3), this.sourcePreviewNodeOptions.delete(e3);
    };
  }
  connectDropTarget(e3, t2) {
    const r2 = this.options.rootElement;
    if (!this.document || !r2)
      return () => {
      };
    const n2 = (n3) => {
      if (!this.document || !r2 || !this.monitor.isDragging())
        return;
      let o2;
      switch (n3.type) {
        case qt.mouse.move:
          o2 = { x: n3.clientX, y: n3.clientY };
          break;
        case qt.touch.move:
          var i2, s2;
          o2 = { x: (null === (i2 = n3.touches[0]) || void 0 === i2 ? void 0 : i2.clientX) || 0, y: (null === (s2 = n3.touches[0]) || void 0 === s2 ? void 0 : s2.clientY) || 0 };
      }
      const a2 = null != o2 ? this.document.elementFromPoint(o2.x, o2.y) : void 0, c2 = a2 && t2.contains(a2);
      return a2 === t2 || c2 ? this.handleMove(n3, e3) : void 0;
    };
    return this.addEventListener(this.document.body, "move", n2), this.targetNodes.set(e3, t2), () => {
      this.document && (this.targetNodes.delete(e3), this.removeEventListener(this.document.body, "move", n2));
    };
  }
  getTopMoveStartHandler() {
    return this.options.delayTouchStart || this.options.delayMouseStart ? this.handleTopMoveStartDelay : this.handleTopMoveStart;
  }
  installSourceNodeRemovalObserver(e3) {
    this.uninstallSourceNodeRemovalObserver(), this.draggedSourceNode = e3, this.draggedSourceNodeRemovalObserver = new MutationObserver(() => {
      e3 && !e3.parentElement && (this.resurrectSourceNode(), this.uninstallSourceNodeRemovalObserver());
    }), e3 && e3.parentElement && this.draggedSourceNodeRemovalObserver.observe(e3.parentElement, { childList: true });
  }
  resurrectSourceNode() {
    this.document && this.draggedSourceNode && (this.draggedSourceNode.style.display = "none", this.draggedSourceNode.removeAttribute("data-reactid"), this.document.body.appendChild(this.draggedSourceNode));
  }
  uninstallSourceNodeRemovalObserver() {
    this.draggedSourceNodeRemovalObserver && this.draggedSourceNodeRemovalObserver.disconnect(), this.draggedSourceNodeRemovalObserver = void 0, this.draggedSourceNode = void 0;
  }
  constructor(e3, t2, r2) {
    this.getSourceClientOffset = (e4) => {
      const t3 = this.sourceNodes.get(e4);
      return t3 && function(e5) {
        const t4 = 1 === e5.nodeType ? e5 : e5.parentElement;
        if (!t4)
          return;
        const { top: r3, left: n2 } = t4.getBoundingClientRect();
        return { x: n2, y: r3 };
      }(t3);
    }, this.handleTopMoveStartCapture = (e4) => {
      Nt(e4) && (this.moveStartSourceIds = []);
    }, this.handleMoveStart = (e4) => {
      Array.isArray(this.moveStartSourceIds) && this.moveStartSourceIds.unshift(e4);
    }, this.handleTopMoveStart = (e4) => {
      if (!Nt(e4))
        return;
      const t3 = Rt(e4);
      t3 && (jt(e4) && (this.lastTargetTouchFallback = e4.targetTouches[0]), this._mouseClientOffset = t3), this.waitingForDelay = false;
    }, this.handleTopMoveStartDelay = (e4) => {
      if (!Nt(e4))
        return;
      const t3 = e4.type === qt.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart;
      this.timeout = setTimeout(this.handleTopMoveStart.bind(this, e4), t3), this.waitingForDelay = true;
    }, this.handleTopMoveCapture = () => {
      this.dragOverTargetIds = [];
    }, this.handleMove = (e4, t3) => {
      this.dragOverTargetIds && this.dragOverTargetIds.unshift(t3);
    }, this.handleTopMove = (e4) => {
      if (this.timeout && clearTimeout(this.timeout), !this.document || this.waitingForDelay)
        return;
      const { moveStartSourceIds: t3, dragOverTargetIds: r3 } = this, n2 = this.options.enableHoverOutsideTarget, o2 = Rt(e4, this.lastTargetTouchFallback);
      if (!o2)
        return;
      if (this._isScrolling || !this.monitor.isDragging() && function(e5, t4, r4, n3, o3) {
        if (!o3)
          return false;
        const i3 = 180 * Math.atan2(n3 - t4, r4 - e5) / Math.PI + 180;
        for (let e6 = 0; e6 < o3.length; ++e6) {
          const t5 = o3[e6];
          if (t5 && (null == t5.start || i3 >= t5.start) && (null == t5.end || i3 <= t5.end))
            return true;
        }
        return false;
      }(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, o2.x, o2.y, this.options.scrollAngleRanges))
        return void (this._isScrolling = true);
      var i2, s2, a2, c2;
      if (!this.monitor.isDragging() && this._mouseClientOffset.hasOwnProperty("x") && t3 && (i2 = this._mouseClientOffset.x || 0, s2 = this._mouseClientOffset.y || 0, a2 = o2.x, c2 = o2.y, Math.sqrt(Math.pow(Math.abs(a2 - i2), 2) + Math.pow(Math.abs(c2 - s2), 2)) > (this.options.touchSlop ? this.options.touchSlop : 0)) && (this.moveStartSourceIds = void 0, this.actions.beginDrag(t3, { clientOffset: this._mouseClientOffset, getSourceClientOffset: this.getSourceClientOffset, publishSource: false })), !this.monitor.isDragging())
        return;
      const u2 = this.sourceNodes.get(this.monitor.getSourceId());
      this.installSourceNodeRemovalObserver(u2), this.actions.publishDragSource(), e4.cancelable && e4.preventDefault();
      const l2 = (r3 || []).map((e5) => this.targetNodes.get(e5)).filter((e5) => !!e5), d2 = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(o2.x, o2.y, l2) : this.document.elementsFromPoint(o2.x, o2.y), h2 = [];
      for (const e5 in d2) {
        if (!d2.hasOwnProperty(e5))
          continue;
        let t4 = d2[e5];
        for (null != t4 && h2.push(t4); t4; )
          t4 = t4.parentElement, t4 && -1 === h2.indexOf(t4) && h2.push(t4);
      }
      const g2 = h2.filter((e5) => l2.indexOf(e5) > -1).map((e5) => this._getDropTargetId(e5)).filter((e5) => !!e5).filter((e5, t4, r4) => r4.indexOf(e5) === t4);
      if (n2)
        for (const e5 in this.targetNodes) {
          const t4 = this.targetNodes.get(e5);
          if (u2 && t4 && t4.contains(u2) && -1 === g2.indexOf(e5)) {
            g2.unshift(e5);
            break;
          }
        }
      g2.reverse(), this.actions.hover(g2, { clientOffset: o2 });
    }, this._getDropTargetId = (e4) => {
      const t3 = this.targetNodes.keys();
      let r3 = t3.next();
      for (; false === r3.done; ) {
        const n2 = r3.value;
        if (e4 === this.targetNodes.get(n2))
          return n2;
        r3 = t3.next();
      }
    }, this.handleTopMoveEndCapture = (e4) => {
      this._isScrolling = false, this.lastTargetTouchFallback = void 0, function(e5) {
        return void 0 === e5.buttons || 0 == (e5.buttons & xt);
      }(e4) && (this.monitor.isDragging() && !this.monitor.didDrop() ? (e4.cancelable && e4.preventDefault(), this._mouseClientOffset = {}, this.uninstallSourceNodeRemovalObserver(), this.actions.drop(), this.actions.endDrag()) : this.moveStartSourceIds = void 0);
    }, this.handleCancelOnEscape = (e4) => {
      "Escape" === e4.key && this.monitor.isDragging() && (this._mouseClientOffset = {}, this.uninstallSourceNodeRemovalObserver(), this.actions.endDrag());
    }, this.options = new Pt(r2, t2), this.actions = e3.getActions(), this.monitor = e3.getMonitor(), this.sourceNodes = /* @__PURE__ */ new Map(), this.sourcePreviewNodes = /* @__PURE__ */ new Map(), this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map(), this.targetNodes = /* @__PURE__ */ new Map(), this.listenerTypes = [], this._mouseClientOffset = {}, this._isScrolling = false, this.options.enableMouseEvents && this.listenerTypes.push(Lt.mouse), this.options.enableTouchEvents && this.listenerTypes.push(Lt.touch), this.options.enableKeyboardEvents && this.listenerTypes.push(Lt.keyboard);
  }
};
var zt = function(e3, t2 = {}, r2 = {}) {
  return new _t(e3, t2, r2);
};
var Ht = "abcdefgh".split("");
var Bt = { a8: "bR", b8: "bN", c8: "bB", d8: "bQ", e8: "bK", f8: "bB", g8: "bN", h8: "bR", a7: "bP", b7: "bP", c7: "bP", d7: "bP", e7: "bP", f7: "bP", g7: "bP", h7: "bP", a2: "wP", b2: "wP", c2: "wP", d2: "wP", e2: "wP", f2: "wP", g2: "wP", h2: "wP", a1: "wR", b1: "wN", c1: "wB", d1: "wQ", e1: "wK", f1: "wB", g1: "wN", h1: "wR" };
var Wt = { a: 0, b: 1, c: 2, d: 3, e: 4, f: 5, g: 6, h: 7 };
var Ut = { a: 7, b: 6, c: 5, d: 4, e: 3, f: 2, g: 1, h: 0 };
var Ft = [7, 6, 5, 4, 3, 2, 1, 0];
var $t = [0, 1, 2, 3, 4, 5, 6, 7];
var Vt = { wP: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsx)("path", { d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z", style: { opacity: "1", fill: "#ffffff", fillOpacity: "1", fillRule: "nonzero", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "miter", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }) })), wR: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "#ffffff", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 34,14 L 31,17 L 14,17 L 11,14" }), (0, import_jsx_runtime.jsx)("path", { d: "M 31,17 L 31,29.5 L 14,29.5 L 14,17", style: { strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,14 L 34,14", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } })] })) })), wN: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z", transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)", style: { fill: "#000000", stroke: "#000000" } })] })) })), wB: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "none", fillRule: "evenodd", fillOpacity: "1", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "#ffffff", stroke: "#000000", strokeLinecap: "butt" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" })] })), (0, import_jsx_runtime.jsx)("path", { d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } })] })) })), wQ: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "#ffffff", stroke: "#000000", strokeWidth: "1.5", strokeLinejoin: "round" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11.5,30 C 15,29 30,29 33.5,30", style: { fill: "none" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12,33.5 C 18,32.5 27,32.5 33,33.5", style: { fill: "none" } }), (0, import_jsx_runtime.jsx)("circle", { cx: "6", cy: "12", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "14", cy: "9", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "22.5", cy: "8", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "31", cy: "9", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "39", cy: "12", r: "2" })] })) })), wK: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 22.5,11.63 L 22.5,6", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 20,8 L 25,8", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25", style: { fill: "#ffffff", stroke: "#000000", strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37", style: { fill: "#ffffff", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,30 C 18,27 27,27 32.5,30", style: { fill: "none", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5", style: { fill: "none", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,37 C 18,34 27,34 32.5,37", style: { fill: "none", stroke: "#000000" } })] })) })), bP: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsx)("path", { d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z", style: { opacity: "1", fill: "#000000", fillOpacity: "1", fillRule: "nonzero", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "miter", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }) })), bR: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "#000000", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z ", style: { strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z ", style: { strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12,35.5 L 33,35.5 L 33,35.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 13,31.5 L 32,31.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 14,29.5 L 31,29.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 14,16.5 L 31,16.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,14 L 34,14", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } })] })) })), bN: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z", style: { fill: "#ffffff", stroke: "#ffffff" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z", transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)", style: { fill: "#ffffff", stroke: "#ffffff" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z ", style: { fill: "#ffffff", stroke: "none" } })] })) })), bB: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { opacity: "1", fill: "none", fillRule: "evenodd", fillOpacity: "1", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "#000000", stroke: "#000000", strokeLinecap: "butt" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" })] })), (0, import_jsx_runtime.jsx)("path", { d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18", style: { fill: "none", stroke: "#ffffff", strokeLinejoin: "miter" } })] })) })), bQ: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "#000000", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z", style: { strokeLinecap: "butt", fill: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11.5,30 C 15,29 30,29 33.5,30" }), (0, import_jsx_runtime.jsx)("path", { d: "m 12,33.5 c 6,-1 15,-1 21,0" }), (0, import_jsx_runtime.jsx)("circle", { cx: "6", cy: "12", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "14", cy: "9", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "22.5", cy: "8", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "31", cy: "9", r: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "39", cy: "12", r: "2" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11,38.5 A 35,35 1 0 0 34,38.5", style: { fill: "none", stroke: "#000000", strokeLinecap: "butt" } }), (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "none", stroke: "#ffffff" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 11,29 A 35,35 1 0 1 34,29" }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,31.5 L 32.5,31.5" }), (0, import_jsx_runtime.jsx)("path", { d: "M 11.5,34.5 A 35,35 1 0 0 33.5,34.5" }), (0, import_jsx_runtime.jsx)("path", { d: "M 10.5,37.5 A 35,35 1 0 0 34.5,37.5" })] }))] })) })), bK: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: (0, import_jsx_runtime.jsxs)("g", Object.assign({ style: { fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [(0, import_jsx_runtime.jsx)("path", { d: "M 22.5,11.63 L 22.5,6", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" }, id: "path6570" }), (0, import_jsx_runtime.jsx)("path", { d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25", style: { fill: "#000000", fillOpacity: "1", strokeLinecap: "butt", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37", style: { fill: "#000000", stroke: "#000000" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 20,8 L 25,8", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5", style: { fill: "none", stroke: "#ffffff" } }), (0, import_jsx_runtime.jsx)("path", { d: "M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37", style: { fill: "none", stroke: "#ffffff" } })] })) })) };
function Yt(e3, t2, r2) {
  const n2 = t2 / 8, o2 = "white" === e3 ? Ft : $t;
  return { x: ("white" === e3 ? Wt : Ut)[r2[0]] * n2 + n2 / 2, y: o2[parseInt(r2[1], 10) - 1] * n2 + n2 / 2 };
}
function Kt(e3) {
  let t2 = false;
  return Object.keys(Bt).forEach((r2) => {
    e3[r2] !== Bt[r2] && (t2 = true);
  }), Object.keys(e3).forEach((r2) => {
    Bt[r2] !== e3[r2] && (t2 = true);
  }), t2;
}
function Xt(e3) {
  return "start" === e3 ? Bt : "string" == typeof e3 ? function(e4) {
    if (!function(e5) {
      e5 = e5.replace(/ .+$/, ""), e5 = function(e6) {
        return e6.replace(/8/g, "11111111").replace(/7/g, "1111111").replace(/6/g, "111111").replace(/5/g, "11111").replace(/4/g, "1111").replace(/3/g, "111").replace(/2/g, "11");
      }(e5);
      const t3 = e5.split("/");
      if (8 !== t3.length)
        return false;
      for (let e6 = 0; e6 < 8; e6++)
        if (8 !== t3[e6].length || -1 !== t3[e6].search(/[^kqrnbpKQRNBP1]/))
          return false;
      return true;
    }(e4))
      return {};
    const t2 = (e4 = e4.replace(/ .+$/, "")).split("/"), r2 = {};
    let n2 = 8;
    for (let e5 = 0; e5 < 8; e5++) {
      const o2 = t2[e5].split("");
      let i2 = 0;
      for (let e6 = 0; e6 < o2.length; e6++)
        if (-1 !== o2[e6].search(/[1-8]/)) {
          i2 += parseInt(o2[e6], 10);
        } else {
          r2[Ht[i2] + n2] = Gt(o2[e6]), i2 += 1;
        }
      n2 -= 1;
    }
    return r2;
  }(e3) : e3;
}
function Gt(e3) {
  return e3.toLowerCase() === e3 ? "b" + e3.toUpperCase() : "w" + e3.toUpperCase();
}
var Qt = (e3) => Array.from(e3).map((e4) => e4.split(","));
var Jt = (e3, t2 = true, r2) => {
  const [n2, o2] = (0, import_react.useState)(/* @__PURE__ */ new Set()), [s2, c2] = (0, import_react.useState)();
  (0, import_react.useEffect)(() => {
    e3 && (0 !== e3.length || n2.size > 0) && o2(((e4) => new Set(null == e4 ? void 0 : e4.map((e5) => e5.join(","))))(e3));
  }, [e3]), (0, import_react.useEffect)(() => {
    null == r2 || r2(Qt(n2));
  }, [n2]);
  return { arrows: Qt(n2), newArrow: s2, clearArrows: function() {
    o2(/* @__PURE__ */ new Set()), c2(void 0);
  }, removeArrow: (e4, t3) => {
    let r3;
    const i2 = Array.from(n2);
    for (const [n3] of i2.entries())
      i2[n3][0] === e4 && i2[n3][1] === t3 && (o2((e5) => {
        const t4 = [...e5];
        return t4.splice(n3, 1), new Set(t4);
      }), r3 = [e4, t3]);
    return Boolean(r3);
  }, drawNewArrow: (e4, r3) => {
    t2 && e4 !== r3 && c2([e4, r3]);
  }, setArrows: o2, onArrowDrawEnd: (e4, t3) => {
    if (e4 === t3)
      return;
    const r3 = `${e4},${t3}`, i2 = new Set(n2);
    i2.has(r3) ? i2.delete(r3) : i2.add(r3), c2(void 0), o2(i2);
  } };
};
var Zt = (0, import_react.createContext)({});
var er = () => (0, import_react.useContext)(Zt);
var tr = (0, import_react.forwardRef)(({ animationDuration: t2 = 300, areArrowsAllowed: r2 = true, arePiecesDraggable: n2 = true, arePremovesAllowed: o2 = false, boardOrientation: s2 = "white", boardWidth: c2, children: u2, clearPremovesOnRightClick: l2 = true, customArrows: d2, customArrowColor: h2 = "rgb(255,170,0)", customBoardStyle: g2, customDarkSquareStyle: v2 = { backgroundColor: "#B58863" }, customDropSquareStyle: m2 = { boxShadow: "inset 0 0 1px 6px rgba(255,255,255,0.75)" }, customLightSquareStyle: y = { backgroundColor: "#F0D9B5" }, customPieces: b2, customPremoveDarkSquareStyle: O2 = { backgroundColor: "#A42323" }, customPremoveLightSquareStyle: w2 = { backgroundColor: "#BD2828" }, customSquare: S2 = "div", customSquareStyles: D2, dropOffBoardAction: C2 = "snapback", id: T2 = 0, isDraggablePiece: E2 = () => true, getPositionObject: I2 = () => {
}, onArrowsChange: k2 = () => {
}, onDragOverSquare: L2 = () => {
}, onMouseOutSquare: P2 = () => {
}, onMouseOverSquare: x2 = () => {
}, onPieceClick: M2 = () => {
}, onPieceDragBegin: N2 = () => {
}, onPieceDragEnd: j2 = () => {
}, onPieceDrop: R2 = () => true, onPromotionCheck: A2 = (e3, t3, r3) => ("wP" === r3 && "7" === e3[1] && "8" === t3[1] || "bP" === r3 && "2" === e3[1] && "1" === t3[1]) && Math.abs(e3.charCodeAt(0) - t3.charCodeAt(0)) <= 1, onPromotionPieceSelect: q2, onSquareClick: _2 = () => {
}, onSquareRightClick: z2 = () => {
}, position: H2 = "start", promotionDialogVariant: B2 = "default", promotionToSquare: W2 = null, showBoardNotation: U2 = true, showPromotionDialog: F2 = false, snapToCursor: $2 = true, autoPromoteToQueen: V2 = false }, Y2) => {
  const [K2, X2] = (0, import_react.useState)(Xt(H2)), [G2, Q2] = (0, import_react.useState)({ removed: {}, added: {} }), [J2, Z2] = (0, import_react.useState)(void 0), [ee2, te2] = (0, import_react.useState)(F2 && !V2), [re2, ne2] = (0, import_react.useState)(null), [oe2, ie2] = (0, import_react.useState)(W2), [se2, ae2] = (0, import_react.useState)([]), ce2 = (0, import_react.useRef)(se2), [ue2, le2] = (0, import_react.useState)(), [de2, he2] = (0, import_react.useState)(Object.assign(Object.assign({}, Vt), b2)), [ge2, fe2] = (0, import_react.useState)(false), [pe2, ve2] = (0, import_react.useState)(), [me2, ye2] = (0, import_react.useState)(false);
  (0, import_react.useImperativeHandle)(Y2, () => ({ clearPremoves(e3 = true) {
    Te2(e3);
  } })), (0, import_react.useEffect)(() => {
    he2(Object.assign(Object.assign({}, Vt), b2));
  }, [b2]), (0, import_react.useEffect)(() => {
    te2(F2), ie2(W2);
  }, [W2, F2]), (0, import_react.useEffect)(() => {
    var e3, r3, n3;
    Ee2();
    const i2 = Xt(H2), s3 = function(e4, t3) {
      const r4 = { removed: {}, added: {} };
      return Object.keys(e4).forEach((n4) => {
        t3[n4] !== e4[n4] && (r4.removed[n4] = e4[n4]);
      }), Object.keys(t3).forEach((n4) => {
        e4[n4] !== t3[n4] && (r4.added[n4] = t3[n4]);
      }), r4;
    }(K2, i2), a2 = (null === (e3 = Object.keys(s3.added)) || void 0 === e3 ? void 0 : e3.length) <= 2 ? null === (n3 = null === (r3 = Object.entries(s3.added)) || void 0 === r3 ? void 0 : r3[0]) || void 0 === n3 ? void 0 : n3[1][0] : void 0;
    if (me2)
      X2(i2), ye2(false), o2 && Ce2(a2), pe2 && clearTimeout(pe2);
    else if (ge2)
      X2(i2), ye2(false), o2 && Ce2(a2);
    else {
      Kt(i2) && void 0 !== J2 ? Z2(a2) : Kt(i2) ? Z2(void 0) : Z2("b"), Q2(s3), ye2(true);
      const e4 = setTimeout(() => {
        X2(i2), ye2(false), o2 && Ce2(a2);
      }, t2);
      ve2(e4);
    }
    return fe2(false), I2(i2), we2(), () => {
      clearTimeout(pe2);
    };
  }, [H2]);
  const { arrows: be2, newArrow: Oe2, clearArrows: we2, drawNewArrow: Se2, onArrowDrawEnd: De2 } = Jt(d2, r2, k2);
  function Ce2(e3) {
    if (0 === ce2.current.length)
      return;
    const t3 = ce2.current[0];
    if (void 0 !== t3.piece[0] && t3.piece[0] !== e3 && R2.length) {
      Z2(t3.piece[0]), fe2(true);
      if (R2(t3.sourceSq, t3.targetSq, t3.piece)) {
        const e4 = [...ce2.current];
        e4.shift(), ce2.current = e4, ae2([...e4]);
      } else
        Te2();
    }
  }
  function Te2(e3 = true) {
    e3 && Z2(void 0), ce2.current = [], ae2([]);
  }
  function Ee2() {
    ne2(null), ie2(null), te2(false);
  }
  const Ie2 = { animationDuration: t2, arePiecesDraggable: n2, arePremovesAllowed: o2, boardOrientation: s2, boardWidth: c2, customArrowColor: h2, customBoardStyle: g2, customDarkSquareStyle: v2, customDropSquareStyle: m2, customLightSquareStyle: y, customPremoveDarkSquareStyle: O2, customPremoveLightSquareStyle: w2, customSquare: S2, customSquareStyles: D2, id: T2, isDraggablePiece: E2, onDragOverSquare: L2, onMouseOutSquare: P2, onMouseOverSquare: x2, onPieceClick: M2, onPieceDragBegin: N2, onPieceDragEnd: j2, onPieceDrop: R2, onPromotionCheck: A2, onPromotionPieceSelect: q2, onSquareClick: _2, showBoardNotation: U2, snapToCursor: $2, promotionDialogVariant: B2, arrows: be2, newArrow: Oe2, onArrowDrawEnd: De2, chessPieces: de2, clearArrows: we2, drawNewArrow: Se2, clearCurrentRightClickDown: function() {
    le2(void 0);
  }, currentPosition: K2, handleSetPosition: function(e3, t3, r3, n3) {
    if (e3 === t3)
      return;
    if (we2(), o2 && me2 || o2 && (J2 === r3[0] || ce2.current.filter((e4) => e4.piece[0] === r3[0]).length > 0)) {
      const n4 = [...ce2.current];
      return n4.push({ sourceSq: e3, targetSq: t3, piece: r3 }), ce2.current = n4, ae2([...n4]), void Ee2();
    }
    if (!o2 && me2)
      return;
    const i2 = Object.assign({}, K2);
    if (fe2(!!n3), Z2(r3[0]), R2.length) {
      R2(e3, t3, r3) || Te2();
    } else
      "trash" !== C2 || t3 || delete i2[e3], delete i2[e3], i2[t3] = r3, X2(i2);
    Ee2(), I2(i2);
  }, isWaitingForAnimation: me2, lastPieceColour: J2, onRightClickDown: function(e3) {
    le2(e3);
  }, onRightClickUp: function(e3) {
    if (ue2) {
      if (ue2 === e3)
        return le2(void 0), l2 && Te2(false), void z2(e3);
    } else
      le2(void 0);
  }, positionDifferences: G2, promoteFromSquare: re2, promoteToSquare: oe2, premoves: se2, setPromoteFromSquare: ne2, setPromoteToSquare: ie2, setShowPromoteDialog: te2, showPromoteDialog: ee2, autoPromoteToQueen: V2, currentRightClickDown: ue2 };
  return (0, import_jsx_runtime.jsx)(Zt.Provider, Object.assign({ value: Ie2 }, { children: u2 }));
});
function rr({ row: n2, col: o2 }) {
  const { boardOrientation: i2, boardWidth: s2, customDarkSquareStyle: a2, customLightSquareStyle: c2 } = er(), u2 = c2.backgroundColor, l2 = a2.backgroundColor, d2 = 0 === o2, h2 = 7 === n2;
  function g2() {
    return "white" === i2 ? 8 - n2 : n2 + 1;
  }
  function f2() {
    return "black" === i2 ? Ht[7 - o2] : Ht[o2];
  }
  return d2 && h2 ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: "absolute" }, { color: u2 }), or(s2)) }, { children: g2() })), (0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: "absolute" }, { color: u2 }), nr(s2)) }, { children: f2() }))] }) : h2 ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ userSelect: "none", zIndex: 3, position: "absolute" }, { color: o2 % 2 != 0 ? l2 : u2 }), nr(s2)) }, { children: f2() })) : d2 ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign(Object.assign({ userSelect: "none", zIndex: 3, position: "absolute" }, { color: n2 % 2 == 0 ? l2 : u2 }), or(s2)) }, { children: g2() })) : null;
}
var nr = (e3) => ({ alignSelf: "flex-end", paddingLeft: e3 / 8 - e3 / 48, fontSize: e3 / 48 });
var or = (e3) => ({ alignSelf: "flex-start", paddingRight: e3 / 8 - e3 / 48, fontSize: e3 / 48 });
function ir({ isPremovedPiece: t2 = false, piece: r2, square: n2, squares: o2 }) {
  const { animationDuration: s2, arePiecesDraggable: c2, arePremovesAllowed: u2, boardWidth: l2, chessPieces: d2, currentPosition: h2, id: g2, isDraggablePiece: f2, isWaitingForAnimation: p2, onPieceClick: v2, onPieceDragBegin: m2, onPieceDragEnd: y, positionDifferences: b2, premoves: O2 } = er(), [w2, S2] = (0, import_react.useState)({ opacity: 1, zIndex: 5, touchAction: "none", cursor: c2 && f2({ piece: r2, sourceSquare: n2 }) ? "-webkit-grab" : "default" }), [{ canDrag: D2, isDragging: C2 }, T2, E2] = tt(() => ({ type: "piece", item: () => (m2(r2, n2), { piece: r2, square: n2, id: g2 }), end: () => y(r2, n2), collect: (e3) => ({ canDrag: f2({ piece: r2, sourceSquare: n2 }), isDragging: !!e3.isDragging() }) }), [r2, n2, h2, g2]);
  return E2((Ct || (Ct = new Image(), Ct.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), Ct), { captureDraggingState: true }), (0, import_react.useEffect)(() => {
    S2((e3) => Object.assign(Object.assign({}, e3), { opacity: C2 ? 0 : 1 }));
  }, [C2]), (0, import_react.useEffect)(() => {
    if (!u2)
      return;
    let e3 = false;
    !t2 && O2.find((e4) => e4.targetSq === n2) && (e3 = true), O2.find((e4) => e4.sourceSq === n2 && e4.piece === r2) && (e3 = true), S2((t3) => Object.assign(Object.assign({}, t3), { display: e3 ? "none" : "unset" }));
  }, [h2, O2]), (0, import_react.useEffect)(() => {
    var e3;
    const r3 = null === (e3 = b2.removed) || void 0 === e3 ? void 0 : e3[n2];
    if (!b2.added)
      return;
    const i2 = Object.entries(b2.added).find(([e4, t3]) => t3 === r3 || "P" === (null == r3 ? void 0 : r3[1]) && ("1" === e4[1] || "8" === e4[1]));
    if (p2 && r3 && i2 && !t2) {
      const { sourceSq: e4, targetSq: t3 } = (a2 = n2, c3 = i2[0], { sourceSq: o2[a2], targetSq: o2[c3] });
      e4 && t3 && S2((r4) => Object.assign(Object.assign({}, r4), { transform: `translate(${t3.x - e4.x}px, ${t3.y - e4.y}px)`, transition: `transform ${s2}ms`, zIndex: 6 }));
    }
    var a2, c3;
  }, [b2]), (0, import_react.useEffect)(() => {
    const { sourceSq: e3 } = { sourceSq: o2[n2] };
    e3 && S2((e4) => Object.assign(Object.assign({}, e4), { transform: "translate(0px, 0px)", transition: "transform 0ms" }));
  }, [h2]), (0, import_react.useEffect)(() => {
    S2((e3) => Object.assign(Object.assign({}, e3), { cursor: c2 && f2({ piece: r2, sourceSquare: n2 }) ? "-webkit-grab" : "default" }));
  }, [n2, h2, c2]), (0, import_jsx_runtime.jsx)("div", Object.assign({ ref: c2 && D2 ? T2 : null, onClick: () => v2(r2), "data-piece": r2, style: w2 }, { children: "function" == typeof d2[r2] ? d2[r2]({ squareWidth: l2 / 8, isDragging: C2 }) : (0, import_jsx_runtime.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: l2 / 8, height: l2 / 8 }, { children: (0, import_jsx_runtime.jsx)("g", { children: d2[r2] }) })) }));
}
function sr({ square: t2, squareColor: r2, setSquares: n2, squareHasPremove: o2, children: s2 }) {
  const a2 = (0, import_react.useRef)(null), { autoPromoteToQueen: c2, boardWidth: u2, boardOrientation: l2, clearArrows: d2, currentPosition: h2, currentRightClickDown: g2, customBoardStyle: p2, customDarkSquareStyle: v2, customDropSquareStyle: m2, customLightSquareStyle: y, customPremoveDarkSquareStyle: b2, customPremoveLightSquareStyle: O2, customSquare: w2, customSquareStyles: S2, drawNewArrow: D2, handleSetPosition: C2, isWaitingForAnimation: T2, lastPieceColour: E2, onArrowDrawEnd: I2, onDragOverSquare: k2, onMouseOutSquare: L2, onMouseOverSquare: P2, onPieceDrop: x2, onPromotionCheck: M2, onRightClickDown: N2, onRightClickUp: j2, onSquareClick: R2, setPromoteFromSquare: A2, setPromoteToSquare: q2, setShowPromoteDialog: _2 } = er(), [{ isOver: z2 }, H2] = it(() => ({ accept: "piece", drop: B2, collect: (e3) => ({ isOver: !!e3.isOver() }) }), [t2, h2, x2, T2, E2]);
  function B2(e3) {
    M2(e3.square, t2, e3.piece) ? c2 ? C2(e3.square, t2, "w" === e3.piece[0] ? "wQ" : "bQ") : (A2(e3.square), q2(t2), _2(true)) : C2(e3.square, t2, e3.piece, true);
  }
  (0, import_react.useEffect)(() => {
    if (a2.current) {
      const { x: e3, y: r3 } = a2.current.getBoundingClientRect();
      n2((n3) => Object.assign(Object.assign({}, n3), { [t2]: { x: e3, y: r3 } }));
    }
  }, [u2, l2]);
  const W2 = Object.assign(Object.assign(Object.assign(Object.assign({}, ur(t2, l2, p2)), "black" === r2 ? v2 : y), o2 && ("black" === r2 ? b2 : O2)), z2 && m2);
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ ref: H2, style: W2, "data-square-color": r2, "data-square": t2, onMouseOver: (e3) => {
    2 === e3.buttons && g2 && D2(g2, t2), e3.relatedTarget && e3.currentTarget.contains(e3.relatedTarget) || P2(t2);
  }, onMouseOut: (e3) => {
    e3.relatedTarget && e3.currentTarget.contains(e3.relatedTarget) || L2(t2);
  }, onMouseDown: (e3) => {
    2 === e3.button && N2(t2);
  }, onMouseUp: (e3) => {
    2 === e3.button && (g2 && I2(g2, t2), j2(t2));
  }, onDragEnter: () => k2(t2), onClick: () => {
    R2(t2), d2();
  }, onContextMenu: (e3) => {
    e3.preventDefault();
  } }, { children: (0, import_jsx_runtime.jsx)(w2, "string" == typeof w2 ? Object.assign({ ref: a2, style: Object.assign(Object.assign(Object.assign({}, cr(u2)), ar), !o2 && (null == S2 ? void 0 : S2[t2])) }, { children: s2 }) : Object.assign({ ref: a2, square: t2, squareColor: r2, style: Object.assign(Object.assign(Object.assign({}, cr(u2)), ar), !o2 && (null == S2 ? void 0 : S2[t2])) }, { children: s2 })) }));
}
var ar = { display: "flex", justifyContent: "center" };
var cr = (e3) => ({ width: e3 / 8, height: e3 / 8 });
var ur = (e3, t2, r2) => (null == r2 ? void 0 : r2.borderRadius) ? "a1" === e3 ? "white" === t2 ? { borderBottomLeftRadius: r2.borderRadius } : { borderTopRightRadius: r2.borderRadius } : "a8" === e3 ? "white" === t2 ? { borderTopLeftRadius: r2.borderRadius } : { borderBottomRightRadius: r2.borderRadius } : "h1" === e3 ? "white" === t2 ? { borderBottomRightRadius: r2.borderRadius } : { borderTopLeftRadius: r2.borderRadius } : "h8" === e3 ? "white" === t2 ? { borderTopRightRadius: r2.borderRadius } : { borderBottomLeftRadius: r2.borderRadius } : {} : {};
function lr() {
  const [r2, n2] = (0, import_react.useState)({}), { boardOrientation: o2, boardWidth: i2, currentPosition: s2, customBoardStyle: c2, id: u2, premoves: l2, showBoardNotation: d2 } = er();
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ "data-boardid": u2, style: Object.assign(Object.assign({}, dr(i2)), c2) }, { children: [...Array(8)].map((a2, c3) => (0, import_jsx_runtime.jsx)("div", Object.assign({ style: { display: "flex", flexWrap: "nowrap", width: i2 } }, { children: [...Array(8)].map((i3, a3) => {
    const u3 = "black" === o2 ? Ht[7 - a3] + (c3 + 1) : Ht[a3] + (8 - c3), h2 = a3 % 2 == c3 % 2 ? "white" : "black", g2 = l2.find((e3) => e3.sourceSq === u3 || e3.targetSq === u3), f2 = l2.find((e3) => e3.targetSq === u3);
    return (0, import_jsx_runtime.jsxs)(sr, Object.assign({ square: u3, squareColor: h2, setSquares: n2, squareHasPremove: !!g2 }, { children: [s2[u3] && (0, import_jsx_runtime.jsx)(ir, { piece: s2[u3], square: u3, squares: r2 }), f2 && (0, import_jsx_runtime.jsx)(ir, { isPremovedPiece: true, piece: f2.piece, square: u3, squares: r2 }), d2 && (0, import_jsx_runtime.jsx)(rr, { row: c3, col: a3 })] }), `${a3}${c3}`);
  }) }), c3.toString())) }));
}
var dr = (e3) => ({ cursor: "default", height: e3, width: e3 });
var hr = () => {
  const { arrows: r2, newArrow: n2, boardOrientation: o2, boardWidth: i2, customArrowColor: s2 } = er(), a2 = [...r2, n2].filter(Boolean);
  return (0, import_jsx_runtime.jsx)("svg", Object.assign({ width: i2, height: i2, style: { position: "absolute", top: "0", left: "0", pointerEvents: "none", zIndex: "10" } }, { children: a2.map((n3, a3) => {
    const c2 = Yt(o2, i2, n3[0]), u2 = Yt(o2, i2, n3[1]);
    let l2 = i2 / 32;
    const d2 = a3 === r2.length;
    r2.some((e3) => e3[0] !== n3[0] && e3[1] === n3[1]) && !d2 && (l2 = i2 / 16);
    const h2 = u2.x - c2.x, g2 = u2.y - c2.y, f2 = Math.hypot(g2, h2), p2 = { x: c2.x + h2 * (f2 - l2) / f2, y: c2.y + g2 * (f2 - l2) / f2 };
    return (0, import_jsx_runtime.jsxs)(import_react.Fragment, { children: [(0, import_jsx_runtime.jsx)("marker", Object.assign({ id: "arrowhead", markerWidth: "2", markerHeight: "2.5", refX: "1.25", refY: "1.25", orient: "auto" }, { children: (0, import_jsx_runtime.jsx)("polygon", { points: "0.3 0, 2 1.25, 0.3 2.5", fill: s2 }) })), (0, import_jsx_runtime.jsx)("line", { x1: c2.x, y1: c2.y, x2: p2.x, y2: p2.y, opacity: d2 ? "0.5" : "0.65", stroke: s2, strokeWidth: d2 ? 0.9 * i2 / 36 : i2 / 36, markerEnd: "url(#arrowhead)" })] }, `${n3[0]}-${n3[1]}${d2 ? "active" : ""}`);
  }) }));
};
function gr({ option: t2 }) {
  const [r2, n2] = (0, import_react.useState)(false), { boardWidth: o2, chessPieces: i2, customDarkSquareStyle: s2, customLightSquareStyle: c2, handleSetPosition: u2, onPromotionPieceSelect: l2, promoteFromSquare: d2, promoteToSquare: h2, promotionDialogVariant: g2 } = er(), f2 = () => {
    switch (t2[1]) {
      case "Q":
        return s2.backgroundColor;
      case "R":
        return c2.backgroundColor;
      case "N":
        return "default" === g2 ? c2.backgroundColor : s2.backgroundColor;
      case "B":
        return "default" === g2 ? s2.backgroundColor : c2.backgroundColor;
    }
  };
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ onClick: () => {
    (null == l2 ? void 0 : l2.length) ? l2(t2) : u2(d2, h2, t2, true);
  }, onMouseOver: () => n2(true), onMouseOut: () => n2(false), "data-piece": t2, style: { cursor: "pointer", backgroundColor: r2 ? f2() : `${f2()}aa`, borderRadius: "4px", transition: "all 0.1s ease-out" } }, { children: "function" == typeof i2[t2] ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: { transition: "all 0.1s ease-out", transform: r2 ? "scale(1)" : "scale(0.85)" } }, { children: i2[t2]({ squareWidth: o2 / 8, isDragging: false }) })) : (0, import_jsx_runtime.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: o2 / 8, height: o2 / 8, style: { transition: "all 0.1s ease-out", transform: r2 ? "scale(1)" : "scale(0.85)" } }, { children: (0, import_jsx_runtime.jsx)("g", { children: i2[t2] }) })) }));
}
function fr() {
  const { boardOrientation: t2, boardWidth: r2, promotionDialogVariant: n2, promoteToSquare: o2 } = er(), i2 = "1" === (null == o2 ? void 0 : o2[1]) ? "b" : "w", s2 = [`${null != i2 ? i2 : "w"}Q`, `${null != i2 ? i2 : "w"}R`, `${null != i2 ? i2 : "w"}N`, `${null != i2 ? i2 : "w"}B`], a2 = { default: { display: "grid", gridTemplateColumns: "1fr 1fr", transform: `translate(${-r2 / 8}px, ${-r2 / 8}px)` }, vertical: { transform: `translate(${-r2 / 16}px, ${-r2 / 16}px)` }, modal: { display: "flex", justifyContent: "center", alignItems: "center", transform: `translate(0px, ${3 * r2 / 8}px)`, width: "100%", height: r2 / 4 + "px", top: 0, backgroundColor: "white", left: 0 } }, c2 = Yt(t2, r2, o2 || "a8");
  return (0, import_jsx_runtime.jsx)("div", Object.assign({ style: Object.assign({ position: "absolute", top: `${null == c2 ? void 0 : c2.y}px`, left: `${null == c2 ? void 0 : c2.x}px`, zIndex: 1e3 }, a2[n2]), title: "Choose promotion piece" }, { children: s2.map((t3) => (0, import_jsx_runtime.jsx)(gr, { option: t3 }, t3)) }));
}
var pr = { whiteKing: (0, import_jsx_runtime.jsx)("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", style: { shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", imageRendering: "crisp-edges" }, viewBox: "0 0 4210 12970", x: "0px", y: "0px", fillRule: "evenodd", clipRule: "evenodd", width: "250", height: "250" }, { children: (0, import_jsx_runtime.jsx)("g", { children: (0, import_jsx_runtime.jsx)("path", { style: { fill: "black", fillRule: "nonzero" }, d: "M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z" }) }) })) };
function vr({ children: t2 }) {
  try {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t2 });
  } catch (t3) {
    return console.log(t3), (0, import_jsx_runtime.jsx)(mr, { showError: true });
  }
}
function mr({ showError: r2 = false }) {
  return (0, import_jsx_runtime.jsxs)("div", Object.assign({ style: { display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column" } }, { children: [(0, import_jsx_runtime.jsx)("div", Object.assign({ style: { width: 250, height: 250, transform: "rotate(90deg)" } }, { children: pr.whiteKing })), r2 && (0, import_jsx_runtime.jsx)("h1", { children: "Something went wrong" })] }));
}
function yr() {
  const n2 = (0, import_react.useRef)(null), { boardWidth: o2, clearCurrentRightClickDown: s2, onPromotionPieceSelect: a2, setShowPromoteDialog: c2, showPromoteDialog: u2 } = er();
  return (0, import_react.useEffect)(() => {
    function e3(e4) {
      n2.current && !n2.current.contains(e4.target) && s2();
    }
    return document.addEventListener("mouseup", e3), () => {
      document.removeEventListener("mouseup", e3);
    };
  }, []), o2 ? (0, import_jsx_runtime.jsxs)("div", Object.assign({ ref: n2, style: { position: "relative" } }, { children: [(0, import_jsx_runtime.jsx)(lr, {}), (0, import_jsx_runtime.jsx)(hr, {}), u2 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { onClick: () => {
    c2(false), null == a2 || a2();
  }, style: { position: "absolute", top: "0", left: "0", zIndex: "100", backgroundColor: "rgba(22,21,18,.7)", width: o2, height: o2 } }), (0, import_jsx_runtime.jsx)(fr, {})] })] })) : (0, import_jsx_runtime.jsx)(mr, {});
}
function br() {
  const { boardWidth: t2, chessPieces: r2, id: n2, snapToCursor: o2 } = er(), s2 = function(e3) {
    const t3 = Je().getMonitor(), [r3, n3] = Re(t3, e3);
    return (0, import_react.useEffect)(() => t3.subscribeToOffsetChange(n3)), (0, import_react.useEffect)(() => t3.subscribeToStateChange(n3)), r3;
  }((e3) => ({ item: e3.getItem(), clientOffset: e3.getClientOffset(), sourceClientOffset: e3.getSourceClientOffset(), isDragging: e3.isDragging() })), { isDragging: a2, item: u2, clientOffset: l2, sourceClientOffset: d2 } = s2, h2 = (0, import_react.useCallback)((e3, r3) => {
    if (!e3 || !r3)
      return { display: "none" };
    let { x: n3, y: i2 } = o2 ? e3 : r3;
    if (o2) {
      const e4 = t2 / 8 / 2;
      n3 -= e4, i2 -= e4;
    }
    const s3 = `translate(${n3}px, ${i2}px)`;
    return { transform: s3, WebkitTransform: s3, touchAction: "none" };
  }, [t2, o2]);
  return a2 && u2.id === n2 ? (0, import_jsx_runtime.jsx)("div", Object.assign({ style: { position: "fixed", pointerEvents: "none", zIndex: 10, left: 0, top: 0 } }, { children: (0, import_jsx_runtime.jsx)("div", Object.assign({ style: h2(l2, d2) }, { children: "function" == typeof r2[u2.piece] ? r2[u2.piece]({ squareWidth: t2 / 8, isDragging: true }) : (0, import_jsx_runtime.jsx)("svg", Object.assign({ viewBox: "1 1 43 43", width: t2 / 8, height: t2 / 8 }, { children: (0, import_jsx_runtime.jsx)("g", { children: r2[u2.piece] }) })) })) })) : null;
}
var Or = (0, import_react.forwardRef)((r2, n2) => {
  const { customDndBackend: o2, customDndBackendOptions: s2 } = r2, c2 = function(e3, t2) {
    var r3 = {};
    for (var n3 in e3)
      Object.prototype.hasOwnProperty.call(e3, n3) && t2.indexOf(n3) < 0 && (r3[n3] = e3[n3]);
    if (null != e3 && "function" == typeof Object.getOwnPropertySymbols) {
      var o3 = 0;
      for (n3 = Object.getOwnPropertySymbols(e3); o3 < n3.length; o3++)
        t2.indexOf(n3[o3]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, n3[o3]) && (r3[n3[o3]] = e3[n3[o3]]);
    }
    return r3;
  }(r2, ["customDndBackend", "customDndBackendOptions"]), [u2, l2] = (0, import_react.useState)(), [d2, h2] = (0, import_react.useState)(false), [g2, p2] = (0, import_react.useState)(false), [v2, m2] = (0, import_react.useState)(r2.boardWidth), y = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    p2("ontouchstart" in window), h2(true), l2(window);
  }, []), (0, import_react.useEffect)(() => {
    var e3;
    if (void 0 === r2.boardWidth && (null === (e3 = y.current) || void 0 === e3 ? void 0 : e3.offsetWidth)) {
      const e4 = new ResizeObserver(() => {
        var e5;
        m2(null === (e5 = y.current) || void 0 === e5 ? void 0 : e5.offsetWidth);
      });
      return e4.observe(y.current), () => {
        e4.disconnect();
      };
    }
  }, [y.current, u2]);
  const b2 = o2 || (g2 ? zt : kt);
  return d2 && u2 ? (0, import_jsx_runtime.jsx)(vr, { children: (0, import_jsx_runtime.jsxs)("div", Object.assign({ style: { display: "flex", flexDirection: "column", width: "100%" } }, { children: [(0, import_jsx_runtime.jsx)("div", { ref: y, style: { width: "100%" } }), (0, import_jsx_runtime.jsx)(xe, Object.assign({ backend: b2, context: u2, options: o2 ? s2 : void 0 }, { children: v2 && (0, import_jsx_runtime.jsxs)(tr, Object.assign({ boardWidth: v2 }, c2, { ref: n2 }, { children: [(0, import_jsx_runtime.jsx)(br, {}), (0, import_jsx_runtime.jsx)(yr, {})] })) }))] })) }) : null;
});
export {
  Or as Chessboard
};
/*! Bundled license information:

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-chessboard.js.map
